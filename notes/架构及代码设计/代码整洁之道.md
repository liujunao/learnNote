部分代码参考： [代码解决之道部分代码](https://github.com/liujunao/cleancode)

# 二、有意义的命名

- **名副其实**： 选择体现本意的名称能让人理解和修改代码，如： 单词命名、避免魔数
- **避免误导**： 避免使用与本意相悖的词，如： 避免专有名称、名称类型对应、避免长名称间的不明显差异
- **做有意义的区分**： 命名有意义，避免后续随意更改，如： 避免以数字系列命名、避免废话名称
- **使用读得出来的名称**： 尽可能使用易读易记的单词
- **使用可搜索的名称**： 避免单字母名称和数字常量，比如： 使用静态常量代替数字常量(魔数)
- **避免使用编码**： 避免把类型或作用域编进名称，如： 避免匈牙利标记法、避免成员前缀、避免直接接口编码
- **避免思维映射**： 避免使用自己熟知而他人不知道的名称
- **类名**： 类名或对象名应该是名词或名词短语，而不是动词
- **方法名**： 方法名应当是动词或动词短语，属性访问器、修改器和断言应该根据其值命名，并依 JavaBean 标准添加 get、set、is 等前缀
- **每个概念对应一个词**： 给每个抽象概念选一个词，并且一以贯之，如： controller 和 manager 只选其一
- **别用双关语**： 避免将同一单词用于不同目的
- **使用解决方案领域名称**： 可以使用计算机科学术语、算法名、模式名、数学术语等，如： AccountVisitor
- **使用源自所涉问题领域的名称**： 可以请领域专家设计类名、方法名等
- **添加有意义的语境**： 添加前缀来表示，如： addrFirstName 对比 firstName
- **避免没用的语境**： 只要短名称足够清楚，就要比长名称好

# 三、函数

- **短小**： 函数要足够短小，且函数的缩进层级不该多于一层或两层，这样才易于阅读

- **只做一件事**： 将功能拆解，保证每个函数只做一件事

- **每个函数一个抽象层级**： 函数中的语句要在同一抽象层级

  > **向下规则： 自顶向下读代码**
  >
  > - 要容纳设置和分拆步骤，就先容纳设置步骤，然后纳入测试页面内容，再纳入分拆步骤
  > - 要容纳设置步骤，若是套件，就纳入套件设置步骤，然后再纳入普通设置步骤
  > - 要容纳套件设置步骤，先搜索"SuiteSetUp"页面的上级继承关系，再添加一个包括该页面路径的语句

- **switch 语句**： 利用**多态**使 switch 埋藏在较低的抽象层级

- **使用描述性的名称**： 描述性名称的函数更好，别害怕长名称

  > 沃德原则： 若每个例程都让你感到深合己意，那就是整洁代码

- **函数参数**： 参数尽可能少，避免函数使用三个以上的参数
- **无副作用**： 避免修改某种状态，若必须，则**修改所属对象的状态**，且避免使用输出参数
- **分隔指令与询问**： 函数要么修改某对象的状态，要么返回该对象的有关信息，避免二者都干
- **使用异常替代返回错误码**： 抽离 try/catch 代码块、将错误处理抽离、错误码可以使用枚举
- **别重复自己**： 避免代码重复，可以考虑抽离重复代码到新的函数中
- **结构化编程**： **大函数**中只应有一个 return，循环中不能有 break 或 continue，但小函数无所谓

# 四、注释

- **注释不能美化糟糕的代码**： 带有**少量注释的整洁**而有表达力的代码更好
- **用代码来阐述**： 有时只需创建一个描述与注释所言同一事物的函数即可

---

**好注释**： 

- 法律信息： 版权、著作权等放置在源文件开头注释处

  > ```java
  > //Copyright ....
  > //...
  > public class xxx{
  >     
  > }
  > ```

- **提供信息的注释**： 用注释来提供基本信息，如： 注释解释某个抽象方法的返回值

- **对意图的解释**： 对自己该处代码的意图进行解释，如： if 语句的每层作用

- **阐释**： 注释可以把某些晦涩难明的参数或返回值的意义翻译为某种可读形式

- **警示**： 用于警告该段代码的可能后果

- **`TODO` 注释**： 应该做，但还没做的工作

- **放大**： 注释可以放大某种看起来不合理之物的重要性

- **公共 API 中的 Javadoc**： 公共 API 应该被很好的描述，如： Javadoc

---

**坏注释**： 

- **喃喃自语**： 注释未能很好的描述所想表达的东西
- **多余的注释**： 避免无意义的注释
- **误导性注释**： 注释要明白的表达作用，避免误导其他人
- **循规式注释**： **不是**每个函数的注释格式都要满足 Javadoc 格式
- **日志式注释**： 避免注释记录每次修改的日志
- **废话注释**： 避免无意义的废话注释
- **可怕的废话**： 浪费其他人的时间
- **能用函数或变量时就别用注释**： 代码能清楚的表达，则就不用注释
- **位置标记**： 如： 尾部使用一长串无用的斜杠
- **括号后面的注释**： 括号尾部注释有利于长函数，但会给短小、封装的函数带来混乱
- **归属与署名**： 避免代码中出现署名，因为版本控制系统可以记住代码的创建者和修改者
- **注释掉的代码**： 注释掉的代码应及时删掉
- **HTML 注释**： 避免注释中出现 HTML 标识
- **非本地信息**： 注释应在所描述代码的附近，如： 避免本地注释出现系统描述信息
- **信息过多**： 避免注释中出现无关的细节描述
- **不明显的联系**： 注释及其描述的代码间的联系应显而易见，避免注释和代码间的联系不明显
- **函数头**： 短函数不需要太多描述，为只做一件事的短函数选个好名字比注释更好

# 五、格式

**垂直格式**： 

- **向报纸学习**： 源文件最顶部是高层次概念和算法，细节往下逐次展开，直至找到最底层的函数和细节
- **概念间垂直方向上的区隔**： 每行展现一个表达式或子句，每组代码行展示一条完整的思路(空白行隔开)
- **垂直方向上的靠近**： 紧密相关的代码应互相靠近
- **垂直距离**： 变量声明靠近使用位置，实体变量在类的顶部声明，函数调用者在被调用函数的上面，概念相关代码放到一起

---

**横向格式**： 

- **水平方向上的区隔与靠近**： 空格可以联系紧密相关的事物，也可以分割相关性较弱的事物
- **水平对齐**： 不对齐的声明和赋值可以指出重点
- **缩进**： 类中方法相对类缩进，方法相对方法声明缩进，代码块相对其容器代码缩进，以此类推
- **空范围**： while 或 for 的空语句尽量使用括号包围或分号放到另一行

# 六、对象和数据结构

- **数据抽象**： 以抽象形态表述数据
- **数据、对象的反对称性**： 对象把数据隐藏于抽象之后，暴露操作数据的函数
- **得墨忒耳律**： 模板不应了解它所操作对象的内部情形，即对象隐藏数据，曝露操作

- **数据传送对象(DTO)**： 只有公共变量、没有函数的类

# 七、错误处理

- **使用异常而非返回码**： 要么设置错误标识，要么返回错误码会搞乱代码。因此遇到错误，最好抛出异常
- **先写 Try-catch-finally 语句**： try 代码块像是事务，catch 代码块将程序维持在一种持续状态
- **使用不可控异常**： 可控异常违反开放/闭合原则
- **给出异常发生的环境说明**： 应创建信息充分的错误消息，并和异常一起传递出去
- **依调用者需要定义异常类**： 定义异常类时要考虑它们如何被捕获
- **定义常规流程**： 创建一个类或配置一个对象用来处理特例，异常行为被封装到特例对象中
- **别返回 null 值**： 返回 null 根据实际情况而定
- **别传递 null 值**： 避免传递 null 值

# 八、边界

- **使用第三方代码**： 第三方代码应易于理解、难以被误用
- **浏览和学习边界**： 使用第三方代码前，为要使用的第三方代码编写测试

- **学习性测试的好处不只是免费**： 学习性测试是一种精确试验，帮助我们增进对 API 的理解
- **使用尚不存在的代码**： 编写自己想得到的接口，可以在控制之下，保持代码更可读，且集中完成工作
- **整洁的边界**： 边界上的代码需要清晰的分割和定义期望的测试，应避免过多地了解第三方代码中的特定信息

# 九、单元测试

- **TDD 三定律**： 在编写生产代码前，先编写单元测试
  - 定律一： 在编写不能通过的单元测试前，不可编写生产代码
  - 定律二： 只可编写刚好无法通过的单元测试，不能编译也算不通过
  - 止咳编写刚好足以通过当前失败测试的生产代码

- **保持测试整洁**： 测试代码和生产代码一样重要，需要被思考、被设计和被照料，像生产代码一般保持整洁

- **整洁的测试**： 测试代码要具有可读性，明确、简洁、还有足够的表达力
- **每个测试一个断言**： 单个断言是个好规则，退一步，单个测试中的断言数量应该最小化
- **F.I.R.S.T**： 整洁测试遵循的5条规则
  - **快速(Fast)**： 测试应够快
  - **独立(Independent)**： 测试应该互相独立
  - **可重复(Repeatable)**： 测试应当可在任何环境中重复通过
  - **自足验证(Self-Validating)**： 测试应该有布尔值输出
  - **及时(Timely)**： 测试应及时编写

# 十、类

类应该短小： 

- **单一权责原则(SRP)**： 类或模块应有且只有一条加以修改的理由

  > - 系统应由许多短小的类而不是少量巨大的类组成
  > - 每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为

- **内聚**： 类应该只有少量实体变量，类中的每个方法都应该操作一个或多个这种变量

  > - 若一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性
  > - 保持内聚会得到许多短小的类

# 十一、系统

> 如何在较高的抽象层级——系统层级——上保持整洁

- **将系统的构造与使用分开**： 软件系统应将启动过程和起始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在相互缠结的依赖关系

  > - **分解 main**： 将全部构造过程搬迁到 main 或被称之为 main 的模块中
  >
  >   > 设计系统的其余部分时，假设所有对象都已正确构造和设置
  >
  > - **工厂**： 工厂模式让应用自行控制何时创建实体，但构造的细节却隔离于应用程序代码之外
  >
  > - **依赖注入**： 对象不应负责实体化对自身的依赖

- **扩容**： AOP 是一种恢复横贯式关注面模块化的普适手段

- **Java 代理**： 代理没有提供在系统范围内指定执行点的机制，因此 AOP 更好

- **测试驱动系统架构**：  

  - 最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯  Java(或其他语言)对象实现
  - 不同领域之间用最不具有侵害性的方面或类方面工具整合起来，这种架构能测试驱动

- **优化决策**： 模块化和关注面切分成就了分散化管理和决策

  > 拥有模块化关注面的 POJO 系统提供的敏捷能力，允许我们基于最新的知识做出优化的、时机刚好的决策

- **明智使用添加了可论证价值的标准**： 

  - 有了标准，就更易服用想法和组件、雇佣拥有相关经验的人才、封装好点子，以及将组件连接起来
  - 创立标准的过程有时却漫长到行业等不及的程度，有些标准没能与它要服务的采用者的真实需求相结合

- **系统需要领域特定语言(DSL)**： DSL 允许所有抽象层级和应用程序中的所有领域，从高级策略到底层细节，使用  POJO 来表达

  > DSL 是一种单独的小型脚本语言或以标准语言写就的 API，领域专家可以用它编写组织严谨的代码

# 十二、迭进

**简单设计规则**： 

1. **运行所有测试**： 全面测试并持续通过所有测试的系统，就是可测试的系统

   > 遵循编写测试并持续运行测试的简单、明确的规则，系统就会更贴近 OO 低耦合度、高内聚度的目标
   >
   > - 编写测试引致更好的设计

2. **消除重复**： 

   - “小规模复用”可大量降低系统复杂性
   - “模板方法模式”是一种移除高层级重复的通用技巧

3. **保证表达力**： 

   - 选用好名称来表达
   - 保持函数和类的尺寸短小来表达
   - 采用标准命名法来表达

4. **尽可能减少类和方法的数量**： 在保证函数和类短小的同时，保持整个系统短小精悍

# 十三、并发编程

- **并发防御原则**： 

  - **单一权责原则(SRP)**： 方法/类/组件应当只有一个修改理由

    > 建议： 分离并发相关代码与其他代码

  - **限制数据作用域**： 使用 `synchronized` 限制临界区

    > 建议： 谨记数据封装，严格限制对可能被共享的数据访问

  - **使用数据复本**： 避免共享数据，可以复制对象以只读方式对待

  - **线程应尽可能地独立**： 每个线程处理一个客户端请求，从不共享的源头接纳请求数据，存储为本地变量

    > 建议： 尝试将数据分解到可被独立线程(可能在不同处理器上)操作的独立子集

- **执行模型**： 

  - **生产者-消费者模型**： 
    - 一个或多个生产者线程创建某些工作，并置于缓存或队列中
    - 一个或多个消费者线程从队列中获取并完成这些工作
  - **读者-作者模型**： 
    - 读者线程不去读作者线程正在更新的信息
    - 作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题

  - **宴席哲学家**： 哲学家问题

- **警惕同步方法间的依赖**： 避免使用一个共享对象的多个方法

  > 必须使用一个共享对象的多个方法时，写代码的手段： 
  >
  > 1. **基于客户端的锁定**： 客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码
  > 2. **基于服务端的锁定**： 在服务端内创建锁定服务端的方法，调用所有方法，然后解锁，让客户端调用新方法
  > 3. **适配服务端**： 创建执行锁定的中间层

- **保持同步区域微小**： 将同步延展到最小临界区范围外，会增加资源争用、降低执行效率

  > 建议： 尽可能减小同步区域

- **很难编写正确的关闭代码**： 平静关闭的问题与死锁有关

  > 建议： 尽早考虑关闭问题，尽早令其工作正常

---

**测试线程代码**： 好的测试能降低风险

> 建议： 编写有潜力曝露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行。若有测试失败，则跟踪错误
>
> 精炼的建议： 
>
> - 将伪失败看作可能的线程问题
> - 先使非线程代码可工作
> - 编写可插拔的线程代码
> - 编写可调整的线程代码
> - 运行多于处理器数量的线程
> - 在不同平台上运行
> - 调整代码并强迫错误发生

- **将伪失败看作可能的线程问题**： 线程代码导致“不可能失败的”失败

  > 建议： 不要将系统错误归咎于偶发事件

- **先使非线程代码可工作**： 确保线程之外的代码可工作，能放进 POJO 的代码越多越好

  > 建议： 不要同时追踪非线程缺陷和线程缺陷，确保代码在线程之外可工作

- **编写可插拔的线程代码**： 

  > 编写可在数个配置环境下运行的线程代码： 
  >
  > - 单线程与多个线程在执行时不同的情况
  > - 线程代码与实物或测试替身互动
  > - 用运行快速、缓慢和有变动的测试替身执行
  > - 将测试配置为能运行一定数量的迭代
  >
  > 建议： 编写可插拔的线程代码，这样就能在不同的配置环境下运行

- **编写可调整的线程代码**： 
  - 在不同的配置环境下监测系统性能，要允许线程数量可调整
  - 在系统运行时，允许线程发生变动，允许线程依据吞吐量和系统使用率自我调整

- **运行多于处理器数量的线程**： 任务交换越频繁，越可能找到错误临界区域或导致死锁的代码
- **装置试错代码**： 线程中的缺陷很难重现，因此增加对 `Object.wait(), Object.sleep(), Object.yield(), Object.priority` 等方法的调用，改变代码执行顺序

两种装置代码方法： 

- **硬编码**： 手工插入 `wait, sleep, yield, priority` 等的调用
- **自动化**： 使用 Aspect-Oriented Framework、CGLIB、ASM 之类工具通过编程来装置代码