# 一、认识 Kafka

## 1、快速入门

- **启动 ZooKeeperr**：`bin/zookeeper-server-start.sh config/zookeeper.properties` 

  > 终端输出 `0.0.0.0/0.0.0.0:2181` 表明 zookeeper 已成功在端口 2181 启动

- **启动 kafka**：`bin/kafka-server-start.sh config/server.properties`

- **创建 topic**：`bin/kafka-topics.sh --create --zookeeper localhost:2181 --partitions 1 --replication-factor 1 --topic test` 

  > - **主题(topic)**：用于消息的发送与接收，此处将创建一个名为 `test` 的 topic，该 topic 只有一个分区(partition)，且该 partition  也只有一个副本(replication)处理消息
  >
  > - 查看 topic 状态：`bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test`
  >
  >   <img src="../../pics/kafka/kafka_1.png">

- **创建生产者(发送消息)**：`bin/kafka-console-producer.bat --broker-list localhost:9092 --topic test` 

  > kafka 提供的脚本工具：可以不断接收标准输入并将它们发送到 kafka 的某个 topic

- **创建消费者(接收消息)**：`bin/kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning` 

## 2、消息引擎(消息队列/消息中间件)系统

**消息引擎系统 `MS`**：用于在不同应用间传输消息的系统

> 消息引擎系统以软件接口为主要形式，实现了松耦合的异步式数据语义传递

<img src="../../pics/kafka/kafka_2.png">

消息引擎系统的两个重要因素：

- **消息设计**：要考虑语义的清晰和格式上的通用性，能完整清晰表达业务的能力

  > 为了更好地表达语义以及最大限度地提高重用性，消息通常采用**结构化方式进行设计**，比如：
  >
  > - SOAP 协议的消息采用 XML 格式
  > - WebService 支持 JSON 格式的消息

- **传输协议设计**：

  - 侠义角度：消息传输协议指定了消息在不同系统间传输的方式，如：AMQP、Web Service + SOAP
  - 广义角度：这类协议可能包括任何能在不同系统间传输消息或执行语义操作的协议或框架，如：RPC

---

**消息引擎范型**：一个基于网络的架构范型，描述了消息引擎系统的两个不同的子部分是如何互连且交互

- **消息队列模型**：基于队列提供消息传输服务，多用于进程间通信及线程间通信

  > 该模型定义了消息队列、发送者、接收者，提供了一种点对点的消息传递方式，即：
  >
  > - 发送者发送每条消息到队列指定位置，接收者从指定位置获取消息
  > - 一旦消息被消费，就会从队列中移除该消息
  > - 每条消息由一个发送者生产，且只被一个消费者处理
  >
  > <img src="../../pics/kafka/kafka_3.png">

- **发布/订阅模型**：发布者将消息生产出来发送到指定的 topic 中，所有订阅了该 topic 的订阅者都可以接收到该 topic 下的所有消息

  > 主题 `topic`：可理解为逻辑语义相近的消息容器
  >
  > - 通常具有相同订阅 topic 的所有订阅者将接收到同样的消息
  >
  > <img src="../../pics/kafka/kafka_4.png">

---

Java 消息服务 `JMS`：是一套 API 规范，提供了很多接口用于实现分布式系统间的消息传递

## 3、kafka 概要设计

> kafka 为解决超大量级数据的实时传输

### (1) 吞吐量/延时

- **吞吐量**：某种处理能力的最大值

  > kafka 吞吐量：每秒能处理的消息数或每秒能处理的字节数

- **延时**：性能指标，衡量一段时间间隔内，如：发出某个操作到接收到操作响应之间的时间或在系统中导致某些物理变更的起始时刻与变更正式生效时刻间的间隔

  > kafka 延时：表示客户端发起请求与服务器处理请求并发送响应给客户端间的这段时间

---

- **kafka 的写入操作很快**：每次写入操作都只是把数据写入到操作系统的页缓存中，然后由操作系统自行决定何时把页缓存中的数据写回磁盘，这样的优势

  - 操作系统页缓存是在内存中分配的，所以消息写入的速度非常快

  - Kafka 不必直接与底层的文件系统打交道，所以烦琐的 I/O 操作都交由操作系统来处理

  - Kafka 写入操作采用追加写入方式，避免了磁盘随机写操作，即只能在日志文件末尾追加写入新的消息，且不允许修改已写入的消息，因此属于磁盘顺序操作

    > 磁盘的顺序读/写操作很快，其速度甚至可以匹敌内存的随机 I/O 速度
    >
    > <img src="../../pics/kafka/kafka_5.png">

- **Kafka 使用零拷贝读取**：先尝试从页缓存读取，若命中便把消息经页缓存直接发送到网络的 Socket

  > - **无零拷贝**：数据传输过程涉及内核态与用户态的上下文切换，CPU 开销很大
  >
  >   <img src="../../pics/kafka/kafka_6.png">
  >
  > - **`sendfile` 系统调用(零拷贝)**：在内核驱动程序处理 I/O 数据时，不用直接存储器访问技术`DMA` 执行I/O操作，因此避免了 OS 内核缓冲区间的数据拷贝
  >
  >   <img src="../../pics/kafka/kafka_7.png">

Kafka 实现高吞吐量、低延时目标的操作：

1. 大量使用操作系统页缓存，内存操作速度快且命中率高
2. Kafka 不直接参与物理 I/O 操作，而是交由 OS 完成
3. 采用追加写入方式，摒弃了缓慢的磁盘随机读/写操作
4. 使用 `sendfile` 为代表的零拷贝技术加强网络间的数据传输效率

### (2) 消息持久化

- **把消息持久化到磁盘的好处**：
  - **解耦消息发送与消息消费**：通过将消息持久化使得生产者不再需要直接和消费者耦合，只是简单的把消息生产出来并交由 Kafka 服务器保存即可，因此提升了整体的吞吐量
  - **实现灵活的消息处理**：已处理的消息可能在未来某个时间点需重新处理一次，消息持久化可以方便实现

- **持久化方式**：

  - 普通系统持久化：先尽量使用内存，当内存资源耗尽时，再一次性地把数据“刷盘”

  - Kafka 持久化：所有数据会立即被写入文件系统的持久化日志中，之后 Kafka 服务器才会返回结果给客户端通知其消息已被成功写入

    > 好处：即实时保存数据，又减少 Kafka 程序对于内存的消耗，从而将节省出的内存留给页缓存使用

### (3) 负载均衡和故障转移

- **负载均衡**：让系统负载根据一定的规则均衡地分配在所有参与工作的服务器上，从而最大限度地提升系统整体的运行效率

  > kafka 通过**智能化的分区领导者选举**实现负载均衡

- **故障转移**：当服务器意外中止时，整个集群可以快速地检测到该失效，并立即将该服务器上的应用或服务自动转移到其他服务器上

  > 通常以“心跳”或“会话”机制实现，即只要主服务器与备份服务器之间的心跳无法维持或主服务器注册到服务中心的会话超过过期时间，就认为主服务器已无法正常运行，集群会自动启动某个备份服务器来替代
  >
  > ---
  >
  > Kafka 使用**会话机制**来支持故障转移：
  >
  > - 每台 Kafka 服务器启动后，会以会话形式把自己注册到 ZooKeeper 服务器上
  > - 一旦该服务器运行出现问题，与 ZooKeeper 的会话便不能维持从而超时失效
  > - 此时，Kafka 集群会选举出另一台服务器来完全代替这台服务器继续服务

### (4) 伸缩性

- **伸缩性**：表示向分布式系统中增加额外的计算资源时吞吐量提升的能力

- **Kafka 伸缩性**：每台 Kafka 服务器上的状态统一交由 ZooKeeper 保管

  > Kafka 服务器上并不是所有状态都不保存，其只保存了很轻量级的内部状态，因此整个集群间维护状态一致性的代价很低

---

分布式集群的每台服务器会维护很多内部状态：

- 若由服务器来保存状态信息，则必须要处理一致性问题

- 若服务器无状态，状态的保存和管理交于专门的协调服务，则整个集群的服务器间就无须繁重的状态共享

  > 倘若要扩容集群节点，只需简单地启动新的节点机器进行自动负载均衡即可

---

- 通过消息持久化，Kafka 实现高可靠性
- 通过负载均衡和文件系统的独特设计，Kafka 实现高吞吐量
- 通过故障转移，Kafka 实现高可用性
- 通过 ZooKeeper 状态保存，Kafka 实现伸缩性

## 4、kafka 基本概念与术语







## 5、kafka 使用场景







# 二、kafka 发展历史

## 1、kafka 历史





## 2、kafka 版本





## 3、选择kafka版本







# 三、kafka 线上环境部署

## 1、集群环境规划





## 2、伪分布式环境安装





## 3、多节点环境安装





## 4、验证部署





## 5、参数设置









# 四、producer 开发

## 1、producer 概览





## 2、构造 producer





## 3、消息分区机制





## 4、消息序列化





## 5、producer 拦截器





## 6、无消息丢失配置





## 7、消息压缩





## 8、多线程处理





## 9、旧版本 producer







# 五、consumer 开发

## 1、consumer 概览





## 2、构建 consumer





## 3、订阅 topic





## 4、消息轮询





## 5、位移管理





## 6、重平衡





## 7、解序列化





## 8、多线程消费实例





## 9、独立 consumer





## 10、旧版本 consumer









# 六、kafka 设计原理

## 1、broker 端设计架构





## 2、producer 端设计





## 3、consumer 端设计





## 4、实现精确一次处理语义







# 七、管理 kafka 集群

## 1、集群管理





## 2、topic 管理





## 3、topic 动态配置管理





## 4、consumer 相关管理







## 5、topic 分区管理





## 6、kafka 常见脚本工具





## 7、API 方式管理集群











# 八、监控 kafka 集群

## 1、集群健康度检查





## 2、MBean 监控





## 3、broker 端 JMX 监控





## 4、clients 端 JMX 监控





## 5、JVM 监控





## 6、OS 监控





## 7、主流监控框架







# 九、调优kafka集群

## 1、确定调优目标





## 2、集群基础调优





## 3、调优吞吐量





## 4、调优延时





## 5、调优持久性





## 6、调优可用性







# 十、kafka Connect 与 kafka Streams

## 1、kafka connect





## 2、kafka streams