# 一、概述

## 1、算法表述

- **自然语言**（ENGLISH）


- **算法描述语言**（Pseudo-code）
- **计算机程序语言**(C++,Java)
- **硬件设计**（DSP）

## 2、算法一般特性

- **正确性：** 对于符合输入类型的任意输入数据，都产生正确的输出
- **有效性：** 每一步指令能够被有效的执行，并且规定了指令的执行效果，结果应该具有的数据类型，而且是可以预期的
- **确定性： ** 每一步之后都要有确定的下一步指令
- **有穷性：** 有限步内结束

## 3、算法效率

### (1) 有限资源

- **计算时间**
- **存储空间**
- **网络带宽**

### 2. 资源开销与输入

- **资源开销与输入大小相关：** 文本长度、排序记录条目数量
- **资源开销与输入的组织结构有关：** 无序、有序

## 4、渐进分析

### (1) 渐进分析目的

 **得到一个开销函数的渐进表达式**，如：

​			$${rate(T)}_{n\rightarrow+\infty} = O(f(n))$$

- n：**问题规模**
- T（n）：**资源开销函数**
- f（n）：**问题规模的整函数表达式**

### (2) 渐进分析与阶的增长

- 开销函数的估计是相对的而不是绝对的
- 独立于机器的算法开销估计
- 独立于实现技术的算法自身测度表示
- 关心的是大规模输入的情况

### (3) 符号表示

- $O$ 记号：`f(n) = O(g(n)) if ∃c > 0, n0 > 0, ∀n ≥ n0: 0 ≤ f(n) ≤ c ⋅ g(n)` 
- $Ω$ 记号：`f(n) = Ω(g(n)) if ∃c > 0, n0 > 0, ∀n ≥ n0: 0 ≤ c ⋅ g(n) ≤ f(n) `
- $Θ$ 记号：`f(n) = Θ(g(n)) if ∃c1, c2 > 0, n0 > 0, ∀n ≥ n0: c1 · g(n) ≤ f(n) ≤ c2 ⋅ g(n)`
- $ω$ 记号：`f(n) = ω(g(n)) if ∀c > 0 ∃n0 > 0, ∀n ≥ n0: f(n) ≥ c ⋅ g(n)`
- $o$ 记号：`f(n) = o(g(n)) if ∀c > 0 ∃n0 > 0, ∀n ≥ n0: f(n) ≤ c ⋅ g(n)`


> $o 或 w 对比 O 或 Θ$ 


- $f(n) = O(f(n)) ; f(n) = Ω(f(n)) ; f(n) = Θ(f(n))$ 
- $f(n) = O(g(n))  且 g(n) = O(h(n)) ⇒ f(n) = O(h(n))$ 
- $f(n) = Ω(g(n)) 且g(n) = Ω(h(n)) ⇒ f(n) = Ω(h(n))$ 
- $f(n) = Θ(g(n)) 且g(n) = Θ(h(n)) ⇒ f(n) = Θ(h(n))$
- $ f(n) = O(g(n)) ⇐⇒ g(n) = Ω(f(n))$
- $ f(n) = o(g(n)) ⇐⇒ g(n) = ω(f(n))$ 
- $f(n) = O(g(n)) 且f(n) = Ω(g(n)) ⇒ f(n) = Θ(g(n))$
- $f1(n) = O(g1(n)) 且f2(n) = O(g2(n)) ⇒ f1(n) + f2(n) = O(g1(n) + g2(n))$
- $f(n) = O(g(n)) ⇒ f(n) + g(n) = O(g(n))$ 

---

- $If \lim_{n\rightarrow+\infty} \frac{f(n)}{g(n)} = 0, then f(n) = o(g(n))$ 
- $If \lim_{n\rightarrow+\infty} \frac{f(n)}{g(n)} = +\infty, then f(n) = w(g(n))$
- $If \lim_{n\rightarrow+\infty} \frac{f(n)}{g(n)} = c,∃  c > 0,then f(n) = \theta(g(n))$
- $If \lim_{n\rightarrow+\infty} \frac{f(n)}{g(n)} = 0,then  a^{f(n)} = o(a^{g(n)}),∀a > 1$
- $f(n) = o(g(n)) \Rightarrow a^{f(n)} = o(a^{g(n)}),∀a > 1$
- $f(n) = \theta(g(n)) !=> a^{f(n)} = o(a^{g(n)}),∀a > 1$

## 5、最坏、最好和平均情况

- 输入量为n时的**最大运行步骤数目**
- 输入量为n时的**最小运行步骤数目**
- 输入量为n时的**平均运行步骤数目**

## 6、伪代码中的约定

- **缩进**表示程序中的分程序（程序块）结构

- **while、for、repeat-until** 等循环结构和 **if、then、else** 条件结构与Pascal相同

  > **for 循环** ： 当循环终止，循环计数器的值为第一个超出 for 循环界限的值
  >
  > **to 关键字：**每次迭代增加循环计数器值
  >
  > **downto 关键字：**每次循环减少循环计数器值
  >
  > **by 关键字：**改变循环计数器的该变量，如：by 2 表示循环计数器改变为 1，3，5...

- `//`  表示后面部分是注释

- 多重赋值 `i=j=e` 是将表达式 e 的值赋给变量 i 和 j

- **变量是局部于给定**过程的，在没有显示说明的情况下，我们不使用全局变量

- 数组元素是通过“**数组名[下标]**”这样的形式来进行访问的，**数组下标从 1 开始（伪代码中）**

- 复合数据组织成对象，对象由属性组成；如：**串联访问**`x.f.g`  

- **参数采用按值传递方式**：被调用的过程会收到参数的的一份副本

- return 语句将控制返回到调用点，**允许一个 return 返回多个值（伪代码中）**

- **布尔运算符 `and` 和 `or` 都具有短路能力**，如：

  > 求表达式 `x and y` 的值时：
  >
  > - 首先计算x的值。如果x的值为FALSE，那么整个表达式的值就不可能为TRUE了，因而就无需再对y求值了
  > - 如果x的值为TRUE的话，就必须进一步计算出y的值，才能确定整个表达式的值

- **关键字 error** ：表示调用出现错误，调用过程处理该错误

## 7、复杂度分析

- **渐进时间复杂度**：表示算法的执行时间与数据规模之间的增长关系
- **渐进空间复杂度**：表示算法的存储空间与数据规模之间的增长关系

### (1) 时间复杂度

- `O(1)`：常量级时间复杂度的表示方法，并不是指只执行了一行代码，如：

    ```java
    int i = 8;
    int j = 6;
    int sum = i + j;
    ```

- `O(logn)、O(nlogn)`：

    ```java
    i=1;
    while (i <= n)  {
    	i = i * 2;
    }
    ```

- `O(m+n)、O(m*n)`：此类代码的复杂度由两个数据的规模决定

    > m 和 n 表示两个数据规模，无法事先评估 m 和 n 谁的量级大，因此不能简单地利用加法法则，省略其中一个

    ```java
    int cal(int m, int n) {
    	int sum_1 = 0;
    	int i = 1;
    	for (; i < m; ++i) {
    		sum_1 = sum_1 + i;
    	}
    
    	int sum_2 = 0;
    	int j = 1;
    	for (; j < n; ++j) {
    		sum_2 = sum_2 + j;
    	}
    	return sum_1 + sum_2;
    }
    ```

### (2) 空间复杂度

暂时忽略。。。



### (3) 最好、最坏、平均、均摊时间复杂度分析

#### 3.1 最好、最坏、平均时间情况复杂度

```json
// n表示数组array的长度
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) {
            pos = i;
            break;
        }
    }
    return pos;
}
```

- **最好情况时间复杂度**：在最理想的情况下，执行这段代码的时间复杂度，上述为 `O(n)`

- **最坏情况时间复杂度**：在最糟糕的情况下，执行这段代码的时间复杂度，上述为 `O(1)`

- **(加权)平均情况时间复杂度**：表示一般情况下的时间复杂度，上述为 `O(n)`

    > - 分析一(结论正确，计算过程有问题)：n 个数据，就是 n 种情况，在加上一个不在 n 个数据中的情况，所以共有 n+1 中情况，则  1+..+n 为 n(n+1)/2  ，则再加个 n 就为 n(n+3)/2 ，在除以 n+1 为 n(n+3)/2(n+1)，大 O 表示为 O(n)
    >
    > - **分析二(加权平均值或期望值)**：假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在  0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)
    >
    >     <img src="../../pics/alg/alg_29.png" align=left width=600>

注：一般使用一个复杂度就可以，只有同一块代码在不同情况下，时间复杂度有量级差距，才会使用这三种复杂度表示法来区分

#### 3.2 均摊时间复杂度

代码解释：这段代码实现了一个往数组中插入数据的功能

- 当数组满了之后，即 `count == array.length` 时，用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入
- 若数组一开始就有空闲空间，则直接将数据插入数组

```java
// array 表示一个长度为 n 的数组
int[] array = new int[n];
int count = 0;

void insert(int val) {
    if (count == array.length) {
        int sum = 0;
        for (int i = 0; i < array.length; ++i) {
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }
    array[count] = val;
    ++count;
}
```

代码时间复杂度分析：

- **最好情况时间复杂度**为 `O(1)`

- **最坏情况时间复杂度**为 `O(n)` 

- **平均时间复杂度**：若数组的长度是 n，根据数据插入的位置不同，可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，求得的平均时间复杂度就是：

    <img src="../../pics/alg/alg_30.png" align=left width=600>

---

函数 `insert` 与 `find` 的区别：

- 首先，find() 函数在极端情况下，复杂度才为 O(1)

    但 insert() 在大部分情况下，时间复杂度都为 O(1)，只有个别情况下，复杂度才比较高，为 O(n)

- 其次，对于 insert() 函数，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现频率非常有规律，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复

    > 针对这种特殊的场景，可采用摊还分析法

---

**均摊时间复杂度**：通过摊还分析得到的时间复杂度

> 以 `insert` 理解均摊分析的大致思路：每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)

## 8、递归

> 背景：用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”

- **可以用递归来解决的三个条件**：

    1. 一个问题的解可以分解为几个子问题的解
    2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
    3. 存在递归终止条件

    > ==写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码== 

- **递归代码要警惕堆栈溢出**：如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险

- **递归代码要警惕重复计算**：为了避免重复计算，可以通过一个数据结构(如：散列表)来保存已经求解过的 f(k)

- 怎么将递归代码改写为非递归代码：

    > 递归有利有弊：
    >
    > - 利是递归代码的表达力很强，写起来非常简洁
    > - 弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题

## 9、二分(折半)查找

### (1) 思想

<img src="../../pics/alg/alg_31.png" align=left width=600>

### (2) 实现

- **循环实现**：

```java
public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;

    while (low <= high) {
        int mid = (low + high) / 2;
        if (a[mid] == value) {
            return mid;
        } else if (a[mid] < value) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}
```

- **递归实现**：

```java
// 二分查找的递归实现
public int bsearch(int[] a, int n, int val) {
  return bsearchInternally(a, 0, n - 1, val);
}

private int bsearchInternally(int[] a, int low, int high, int value) {
    if (low > high) return -1;
    int mid =  low + ((high - low) >> 1);
    if (a[mid] == value) {
        return mid;
    } else if (a[mid] < value) {
        return bsearchInternally(a, mid + 1, high, value);
    } else {
        return bsearchInternally(a, low, mid - 1, value);
    }
}
```

### (3) 局限性

- 二分查找依赖的是顺序表结构(即：数组)

    > 数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)

- 二分查找针对的是有序数据

- 数据量太小或太大都不适合二分查找

### (4) 应用

如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位：

假设求 5 的平方根

1. 折半：5/2=2.5，平方校验: 2.5*2.5 = 6.25 > 5，并且得到当前上限 2.5
2. 再次向下折半：2.5/2=1.25，平方校验：1.25*1.25 = 1.5625<5，得到当前下限1.25
3. 再次折半：2.5 - (2.5 - 1.25) / 2 = 1.875，平方校验：1.875*1.875=3.515625<5，得到当前下限1.875

4. 每次得到当前值和5进行比较，并且记下下下限和上限，依次迭代，逐渐逼近平方根

### (5) 变形问题

#### 1. 变体一：查找第一个值等于给定值的元素

> 有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据

<img src="../../pics/alg/alg_32.png" width=600 align=left>

```java
//法一：
public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
        int mid = low + ((high - low) >> 1);
        if (a[mid] >= value) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }

    if (low < n && a[low] == value) return low;
    else return -1;
}

//法二：
public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
            high = mid - 1;
        } else if (a[mid] < value) {
            low = mid + 1;
        } else { //a[mid] == value
            if ((mid == 0) || (a[mid - 1] != value)) return mid; //为什么是 mid - 1，而不是 mid - 2???
            else high = mid - 1;
        }
    }
    return -1;
}
```

#### 2. 变体二：查找最后一个值等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
            high = mid - 1;
        } else if (a[mid] < value) {
            low = mid + 1;
        } else {
            if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
            else low = mid + 1;
        }
    }
    return -1;
}
```

#### 3. 变体三：查找第一个大于等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] >= value) {
            if ((mid == 0) || (a[mid - 1] < value)) return mid;
            else high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
```

#### 4. 变体四：查找最后一个小于等于给定值的元素

```java

public int bsearch7(int[] a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
            high = mid - 1;
        } else {
            if ((mid == n - 1) || (a[mid + 1] > value)) return mid;
            else low = mid + 1;
        }
    }
    return -1;
}
```

# 二、排序算法

- **原地排序**：特指空间复杂度是 O(1) 的排序算法
- **稳定性**：若待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

| 排序方法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度    | 稳定性 | 复杂性 |
| -------- | ---------------- | ---------------- | ---------------- | ------------- | ------ | ------ |
| 插入排序 | $O(n^2)$         | $O(n^2)$         | $O(n)$           | $O(1)$        | 稳定   | 简单   |
| 冒泡排序 | $O(n^2)$         | $O(n^2)$         | $O(n)$           | $O(1)$        | 稳定   | 简单   |
| 选择排序 | $O(n^2)$         | $O(n^2)$         | $O(n^2)$         | $O(1)$        | 不稳定 | 简单   |
| 基数排序 | $O(d(n+r))$      | $O(d(n+r))$      | $O(d(n+r))$      | $O(n+r)$      | 稳定   | 较复杂 |
| 希尔排序 | $O(nlog_2 n)$    | $O(n^2)$         | $O(n)$           | $O(1)$        | 不稳定 | 较复杂 |
| 归并排序 | $O(nlog_2 n)$    | $O(nlog_2 n)$    | $O(nlog_2 n)$    | $O(n)$        | 稳定   | 较复杂 |
| 快速排序 | $O(nlog_2 n)$    | $O(n^2)$         | $O(nlog_2 n)$    | $O(nlog_2 n)$ | 不稳定 | 较复杂 |
| 堆排序   | $O(nlog_2 n)$    | $O(nlog_2 n)$    | $O(nlog_2 n)$    | $O(1)$        | 不稳定 | 较复杂 |

## 1. 插入排序

### 1. 伪代码

```c
InsertionSort(A, n) {
	for i = 2 to n {
		key = A[i]
		j = i - 1
		while (j > 0 and (A[j] > key) {
			A[j+1] = A[j]
			j = j - 1
		}
		A[j+1] = key
	}
}
```

### 2. 详解

![](../../pics/alg/alg_2_1.png)

### 3. 时间复杂度

​								$$T(n) = n^2$$

## 2. 冒泡排序

### 1. 伪代码

```c
void bubble_sort(int arr[], int len) {  
    int i, j;  
    for (i = 0; i < len - 1; i++)          //外层循环控制趟数，总趟数为len-1
        for (j = 0; j < len - 1 - i; j++)  //内层循环为当前i趟数 所需要比较的次数
            if (arr[j] > arr[j + 1])
                swap(arr[j], arr[j + 1]);
} 

//改进版：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作
public void bubbleSort(int[] a, int n) {
	if (n <= 1) return;
    for (int i = 0; i < n; ++i) { // 提前退出冒泡循环的标志位
        boolean flag = false;
        for (int j = 0; j < n - i - 1; ++j) {
            if (a[j] > a[j+1]) { // 交换
                int tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                flag = true;  // 表示有数据交换      
            }
        }
        if (!flag) break;  // 没有数据交换，提前退出
    }
}
```

### 2. 详解

![](../../pics/alg/alg_16.png)

详细步骤： 

1. 比较相邻的元素，如果第一个比第二个大(或小)就交换

2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对

   > 这步做完后，最后的元素会是最大（小）的数

3. 针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）

4. 持续每次对越来越少的元素（无序元素）重复上面的步骤，直到没有任何一对数字需要比较，则序列最终有序

## 3. 选择排序

### 1. 代码

```c
//a -> 待排序的数组；n -> 数组的长度
void select_sort(int a[], int n){
    int i;        // 有序区的末尾位置
    int j;        // 无序区的起始位置
    int min;    // 无序区中最小元素位置

    for(i=0; i<n; i++){
        min=i;
        // 找出"a[i+1] ... a[n]"之间的最小元素，并赋值给min。
        for(j=i+1; j<n; j++){
            if(a[j] < a[min])
                min=j;
        }
        // 若min!=i，则交换 a[i] 和 a[min]。
        // 交换之后，保证了a[0] ... a[i] 之间的元素是有序的
        if(min != i)
            swap(a[i], a[min]);
    }
}
```

### 2. 详解

- 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置
- 接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾
- 以此类推，直到所有元素均排序完毕

![](../../pics/alg/alg_17.png)

排序流程： 

- 第1趟：i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化：20,40,30,10,60,50 -- > 10,40,30,20,60,50
- 第2趟：i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化：10,40,30,20,60,50 -- > 10,20,30,40,60,50
- 第3趟：i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理
- 第4趟：i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理
- 第5趟：i=4。交换a[4]和a[5]的数据。 数列变化：10,20,30,40,60,50 -- > 10,20,30,40,50,60

## 4、计数排序

### (1) 伪代码

```c
//A 输入数组，B 存放排序的输出，C 提供临时储存空间
COUNTING-SORT(A, B, n, k){//假设n个输入元素为0-k之间的整数
	let C[0..k] be a new array
	for i ← 0 to k
		do C[ i ] ← 0
	//计算 C[i]包含等于i的元素的个数
	for j ← 1 to n
		do C[A[ j ]] ← C[A[ j ]] + 1
	//计算 C[i] 包含小于或等于i的元素的个数
	for i ← 1 to k
		do C[ i ] ← C[ i ] + C[i -1]
	for j ← n downto 1
		B[C[A[ j ]]] ← A[ j ]
		C[A[ j ]] ← C[A[ j ]] - 1
}


// java 实现: a是数组，n是数组大小
public void countingSort(int[] a, int n) {
    if (n <= 1) return;

    // 查找数组中数据的范围
    int max = a[0];
    for (int i = 1; i < n; ++i) {
        if (max < a[i]) {
            max = a[i];
        }
    }

    int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
    for (int i = 0; i <= max; ++i) {
        c[i] = 0;
    }

    // 计算每个元素的个数，放入c中
    for (int i = 0; i < n; ++i) {
        c[a[i]]++;
    }

    // 依次累加
    for (int i = 1; i <= max; ++i) {
        c[i] = c[i-1] + c[i];
    }

    // 临时数组r，存储排序之后的结果
    int[] r = new int[n];
    // 计算排序的关键步骤，有点难理解
    for (int i = n - 1; i >= 0; --i) {
        int index = c[a[i]] - 1;
        r[index] = a[i];
        c[a[i]]--;
    }

    // 将结果拷贝给a数组
    for (int i = 0; i < n; ++i) {
        a[i] = r[i];
    }
}
```

### (2) 详解

![](../../pics/alg/alg_2_2.png)

**上图帮助理解思路（与伪代码不符），下图为完整的作答过程（与伪代码相符）：**

![](../../pics/alg/alg_2_11.png)

### (3) 时间复杂度

​					$$T(n) = θ(n+k)$$

## 5、基数排序

### (1) 伪代码

```c
RADIX-SORT(A,d){
	for i = 1 to d
		use a table sort to sort array A on digit i
}
```

### (2) 详解

![](../../pics/alg/alg_2_4.png)

![](../../pics/alg/alg_2_5.png)

### (3) 时间复杂度

​					$$T(n) = O(d * n)$$

## 6、桶排序

### (1) 伪代码

```c
BUCKET-SORT(A){
	n = A.length
	let B[0..n-1] be a new array
	for i ← 1 to n
		insert A[i] into list B[nA[i]] （注意下标）
	for i ← 0 to n - 1
		sort list B[i] with insertion sort （桶内插入排序）
	concatenate lists B[0], B[1], . . . , B[n -1]together in order
	return the concatenated lists
}
```

### (2) 详解

**下图和伪代码不一样（思想一样）：**

![](../../pics/alg/alg_2_6.png)

**操作步骤说明：**

- 设置桶的数量为5个空桶，找到**最大值110，最小值7**，**每个桶的范围 20.8=(110-7+1)/5** 

- 遍历原始数据，以链表结构，放到对应的桶中

  > - 数字7，桶索引值为0：((7 – 7) / 20.8) 余 0
  > - 数字36，桶索引值为1：floor((36 – 7) / 20.8) 余 1

- 当向同一个索引的桶，**第二次插入数据时，判断桶中已存在的数字与新插入数字的大小，按照左到右，从小到大的顺序插入**

  >  如：索引为2的桶，在插入63时，桶中已存在4个数字56，59，60，65，则数字63，插入到65的左边

  **或者按先后顺序存放，然后再进行桶内插入排序（符合伪代码）**

- 合并非空的桶，按从左到右的顺序合并0，1，2，3，4桶。

- 得到桶排序的结果

### (3) 时间复杂度

​					$$T(n) = O(n)$$ 

- 若要排序的数据有 n 个，把均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素
- 每个桶内部使用快速排序，时间复杂度为 $O(k * logk)$，m 个桶排序的时间复杂度就是 $O(m * k * logk)$，因为 k=n/m，所以整个桶排序的时间复杂度就是 $O(n*log(n/m))$
- 当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)

## 7、希尔排序

- 希尔排序是插入排序的一种，它是针对直接插入排序算法的改进，又称**缩小增量排序** 

详解： 

- 将无序数组相隔特定增量分割为若干个子序列，对各个子序列进行插入排序
- 然后再选择一个更小的增量，再将数组分割为多个子序列进行排序
- 最后选择增量为1，即用直接插入排序，使最终数组成为有序

![](../../pics/alg/alg_18.png)

## 8、归并排序

### 1. 伪代码

```c
MERGE(A,p,q,r){//p,q,r 是数组下标，p<=q<=r
	n1 ← q – p + 1
	n2 ← r – q
	let L and R 为左右临时数组 //其中 L 与 R 分别已经排好序
	for i = 1..n1
		do L[i] ← A[p + i – 1]
	for j = 1..n2
		do R[j] ← A[q + j]
	//A:（结束标志）
	L[n1 + 1] ← ∞
	R[n2 + 1] ← ∞
	i ← 1
	j ← 1
	for k = p to r	//遍历 L 与 R 并比较两者元素，将小的放入结果数组 A 中
		do if L[i] ≤ R[j]
			then A[k] ← L[i]
			i ← i + 1
		else A[k] ← R[j]
			j ← j + 1
}

MergeSort(A, p, r){
	if p < r
		//将数组一分为二
		q ← (p + r) / 2
		//分治策略排序子数组，然后再进行合并
		MergeSort(A, p, q)
		MergeSort(A, q + 1, r)
		//合并过程中进行的排序
		Merge(A, p, q, r)
}
```

### 2. 详解

**下图过程没用调用新的数组来存储结果，而是通过交换数组元素顺序来达到存储排序结果的目的：**

![](../../pics/alg/alg_2_3.png)

### 3. 时间复杂度

推导式：

$$T(n) = 2 * T(n/2) + n = 2 * (2 * T(n/4) + O(n/2)) + n = 4 * T (n/4) + 2 * n = ... = 2^k * T(n/2^k) + k * n$$ 

当 $n/2^k = 1$ 时，得到 $k = log_2n$，即 $T(n) = Cn + nlog_2n$

时间复杂度：

$$T(n) = O(n∗logn)$$ 

## 9、快速排序

==推荐阅读==： **[单轴快排(SinglePivotQuickSort)和双轴快排(DualPivotQuickSort)](https://blog.csdn.net/Holmofy/article/details/71168530)** 

### (1) 伪代码

```c
QUICKSORT(A,p,r){
	if p < r
        //使当前数组分为主元左边元素小，右边元素大
		q = PARTITION(A,p,r)
        //对各子数组进行快排
		QUICKSORT(A,p,q-1)
		QUICKSORT(A,q+1,r)
}

PARTITION(A,p,r){//r 为选取的主元
	x = A[r]
	i = p - 1
	for j = p to r - 1
		if A[j] <= x
			i = i + 1
			exchange A[i] with A[j]
	exchange A[i + 1] with A[r] //交换使主元左边元素比其小，右边元素比其大
	return i + 1 //返回主元最终的位置
}

//Java 实现。。。
private static void quickSortC(int[] a, int p, int r) {
    if (p >= r) {
        return;
    }
    int q = partition(a, p, r);
    quickSortC(a, p, q - 1);
    quickSortC(a, q + 1, r);
}

public static int partition(int[] a, int start, int end) {
    int pivot = a[end];
    int i = start;
    for (int j = start; j < end; j++) {
        if (a[j] < pivot) {
            swap(a, i, j);
            i = i + 1;
        }
    }
    swap(a, i, end);
    return i;
}
```

### (2) 详解

**对着伪代码一步一步来：** 

![](../../pics/alg/alg_2_7.png)

- 将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了

### (3) 时间复杂度

​					$$T(n) = O(n∗logn)$$ 

---

推导式：

$$T(n) = 2 * T(n/2) + O(n)$$

时间复杂度：

$$T(n) = O(n∗logn)$$ 

### (4) 算法改进

> 随机快速排序算法同快速排序，只是**主元的选取是随机的** 

#### 1. 切换到插入排序

- 因为快速排序在小数组中也会递归调用自己，**对于小数组，插入排序比快速排序的性能更好** 

#### 2. 三数取中

- 最好情况：每次都取数组的中位数作为切分元素，但是计算中位数的代价很高
- 替代方式： 取 3 个元素并将大小居中的元素作为切分元素的效果最好

#### 3. 防止堆栈过深

快速排序用递归实现，而递归要警惕堆栈溢出。为了递归过深而堆栈过小，导致堆栈溢出，有两种解决办法：

- 第一种是限制递归深度：一旦递归过深，超过事先设定的阈值，就停止递归
- 第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制







#### 4. 三向切分

- 对于有大量重复元素的数组，可以将数组切分为三部分，分别对应**小于、等于和大于**切分元素

- 三向切分快速排序对于只有若干不同主键的随机数组可以在线性时间内完成排序

---

实现： 

- **三分单向扫描**： 为了将序列划分为三个区段我们需要三个变量 `i,j,k` 

  > - 初始化时，i=start，j=end，k=start+1，**k 负责扫描**
  >
  >   ![](../../pics/collection/collection_6.png)
  >
  > - 扫描过程中始终保持：`start~i < pivot ` 元素，`i~k == pivot` 元素，`j~end > pivot` 元素
  >
  >   ![](../../pics/collection/collection_7.png)
  >
  > - 扫描过程中： 
  >
  >   - 遇到 `< pivot` 元素，`i` 与 `k` 元素进行交换，`i++`，然后 `k` 扫描下一个元素
  >
  >     ![](../../pics/collection/collection_8.png)
  >
  >   - 遇到 `> pivot` 元素，`k` 与 `j` 交换，`j–-`，k 不变，继续扫描 `k` 处元素
  >
  >     ![](../../pics/collection/collection_9.png)
  >
  >   - 遇到 `== pivot` 元素，直接扫描下一个元素
  >
  >     > pivot 已经包含在等于pivot的分段中，无需交换
  >
  >     ![](../../pics/collection/collection_10.png)
  >
  > - 最后 `k>j` 时停止扫描
  >
  > 实现代码： 
  >
  > ```java
  > //三分单向扫描
  > public void div3ScanSort(int[] items) {
  >     div3ScanSort(items, 0, items.length - 1);
  > }
  > 
  > public void div3ScanSort(int[] items, int start, int end) {
  >     if (start < end) {
  >         int pivot = items[start];
  >         int i = start, j = end, k = start + 1;
  >         while (k <= j) {
  >             if (items[k] < pivot) {
  >                 swap(items, i, k);
  >                 i++;
  >                 k++;
  >             } else if (items[k] > pivot) {
  >                 swap(items, j, k);
  >                 j--;
  >             } else {
  >                 k++;
  >             }
  >         }
  >         div3ScanSort(items, start, i - 1);
  >         div3ScanSort(items, j + 1, end);
  >     }
  > }
  > ```

- **三分双向扫描**： 

  > - 三分单向扫描的问题： 上面实现中，扫描到 `> pivot` 元素，将 `j` 与 `k` 进行交换，但若交换到 `k` 的元素正好 `> pivot`，则会再次进行交换，这无疑会增加交换的次数
  >
  > - 改进： `j`  交换前进行判断： 
  >   - 若元素 `> pivot`，则 `j++`
  >   - 若元素 `< pivot`，则将 `i` 与 `j` 进行交换
  >   - 若元素 `== pivot`，则将 `k` 与 `j` 进行交换
  >
  > 实现代码： 
  >
  > ```java
  > //双端扫描三分排序
  > public void div3DeScanSort(int[] items) {
  >     div3DeScanSort(items, 0, items.length - 1);
  > }
  > 
  > public void div3DeScanSort(int[] items, int start, int end) {
  >     if (start < end) {
  >         int pivot = items[start];
  >         int i = start, j = end, k = start + 1;
  > 
  >         OUT_LOOP: while (k <= j) {
  >             if (items[k] < pivot) {
  >                 swap(items, i, k);
  >                 i++;
  >                 k++;
  >             } else if (items[k] == pivot) {
  >                 k++;
  >             } else {
  >                 // j向左扫描，直到一个不大于pivot的元素
  >                 while (items[j] > pivot) {
  >                     j--;
  >                     if (k > j) {
  >                         // 后面的待排元素全大于pivot，直接结束排序
  >                         break OUT_LOOP;
  >                     }
  >                 }
  >                 if (items[j] < pivot) {
  >                     swap(items, j, k);
  >                     swap(items, i, k);
  >                     i++;
  >                 } else {
  >                     swap(items, j, k);
  >                 }
  >                 k++;
  >                 j--;
  >             }
  >         }
  >         div3DeScanSort(items, start, i - 1);
  >         div3DeScanSort(items, j + 1, end);
  >     }
  > }
  > ```

### (5) 双轴快排

- 思想： 取两个中心点 `pivot1,pivot2`，且 `pivot≤pivot2`，可将序列分成三段：`x<pivot1、pivot1≤x≤pivot2，x<pivot2`，然后分别对三段进行递归

  ![](../../pics/collection/collection_11.png)

大致过程： 

- 初始化时，`i=start，j=end，k=start+1`，`k` 负责扫描

  序列第一个值大于序列最后一个值，需要进行交换，然后 `pivot1=items[start]，pivot2=items[end]`

- 扫描过程：`1~i` 是 `< pivot1` 元素，`i~k` 是 `>= pivot1 且 <= pivot2` 元素，`j~end-1`是 `> pivot2` 元素

  ![](../../pics/collection/collection_12.png)

- 扫描过程与前面的三分双向扫描类似

- 最后扫描完成，将 pivot1与pivot2 移到中间

  ![](../../pics/collection/collection_13.png)

实现代码： 

```java
//双轴快排
public void dualPivotQuickSort(int[] items) {
    dualPivotQuickSort(items, 0, items.length - 1);
}

public void dualPivotQuickSort(int[] items, int start, int end) {
    if (start < end) {
        if (items[start] > items[end]) {
            swap(items, start, end);
        }
        int pivot1 = items[start], pivot2 = items[end];
        int i = start, j = end, k = start + 1;
        OUT_LOOP: while (k < j) {
            if (items[k] < pivot1) {
                swap(items, ++i, k++);
            } else if (items[k] <= pivot2) {
                k++;
            } else {
                while (items[--j] > pivot2) {
                    if (j <= k) {
                        // 扫描终止
                        break OUT_LOOP;
                    }
                }

                if (items[j] < pivot1) {
                    swap(items, j, k);
                    swap(items, ++i, k);
                } else {
                    swap(items, j, k);
                }
                k++;
            }
        }
        swap(items, start, i);
        swap(items, end, j);

        dualPivotQuickSort(items, start, i - 1);
        dualPivotQuickSort(items, i + 1, j - 1);
        dualPivotQuickSort(items, j + 1, end);
    }
}
```

### (6) 应用：O(n) 时间复杂度内求无序数组中的第 K 大元素

1. 选择数组区间 A[0...n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0...n-1] 原地分区 A[0...p-1]、A[p]、A[p+1...n-1]

2. 若 p+1=K，则 A[p] 就是要求解的元素

    若 K>p+1, 说明第 K 大元素出现在 A[p+1...n-1]区间，再按照上面的思路递归地在 A[p+1...n-1]这个区间内查找。同理，如果 K<p+1，那我们就在 A[0...p-1]区间查找

```java
public class kthMax {
    public static int kthMax(int[] arr, int k) {
        if (arr == null || arr.length < k) {
            return -1;
        }
        int partition = partition(arr, 0, arr.length - 1);
        while (partition + 1 != k) {
            if (partition + 1 < k) {
                partition = partition(arr, partition + 1, arr.length - 1);
            } else {
                partition = partition(arr, 0, partition - 1);
            }
        }
        return arr[partition];
    }
 
    private static int partition(int[] arr, int p, int r) {
        int pivot = arr[r];
        int i = p;
        for (int j = p; j < r; j++) {
            if (arr[j] > pivot) {
                swap(arr, i, j);
                i++;
            }
        }
        swap(arr, i, r);
        return i;
    }
 
    private static void swap(int[] arr, int i, int j) {
        if (i == j) {
            return;
        }
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
 
 
    public static void main(String[] args) {
        int[] arr = {6,1,3,5,7,2,4,9,11,8};
        System.out.println(kthMax(arr, 2));
    }
}
```

## 10、堆排序

### 1. 伪代码

```c
//实现最大堆
MAX-HEAPIFY(A,i)
	l = LEFT(i)
	r = RIGHT(i)
	if l <= A.heap-size and A[l] > A[i]
		largest = l
	else largest = i
	if r <= A.heap-size and A[r] > A[largest]
		largest = r
	if largest != i
		exchange A[i] and A[largest]
		MAX-HEAPIFY(A,largest)
      
//建最大堆
BUILD-MAX-HEAP(A)
	A.heap-size = A.length
	for i = A.length / 2 downto 1
		MAX-HEAPIFY(A,i)
      
//堆排序      
HEAPSORT(A)
	BUILD-MAX-HEAP(A)
	for i = A.length downto 2
		exchange A[1] with A[i]
		A.heap-size = A.heap-size - 1
		MAX-HEAPIFY(A,1)
```

---

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);
        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
            swap(nums, 0, i);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    public void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    public void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

### 2. 详解

**将无序数组构造为最大堆：**

- 首先遍历叶节点，检查其父节点是否比其小，如果是，则与值大的叶节点交换直至满足父节点比子节点大为止
- 然后往上重复进行，直至满足最大堆（**父节点比子节点大**）为止

![](../../pics/alg/alg_2_8.png)

**堆排序：**

- **交换第一个元素与最后一个元素**
- **堆大小减 1**
- **对剩余堆进行最大堆算法**，然后重复上述步骤直到堆无元素为止

![](../../pics/alg/alg_2_9.png)

![](../../pics/alg/alg_2_10.png)

### 3. 时间复杂度

- **MAX-HEAPIFY** 
  - 推导式：$$T(n) = T(2n/3) + \theta(1)$$
  - 时间复杂度：$$T(n) = lg(n)$$
- **BUILD-MAX-HEAP**
  - 时间复杂度： $$T(n) = O(n)$$

- **HEAPSORT**
  - 时间复杂度：$$T(n)=O(n * logn)$$​					

## 11. 全排序

> 题目： 输入一个字符串，按字典序打印出该字符串中字符的所有排列
>
> > 例如： 输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有字符串abc,acb,bac,bca,cab和cba

### 1. 递归实现

- **思路**：问题转换为**先固定第一个字符，求剩余字符的排列**；求剩余字符排列时跟原问题一样

  - 遍历出所有可能出现在第一个位置的字符

    > 即：依次将第一个字符同后面所有字符交换

  - 固定第一个字符，求后面字符的排列

    > 即：在第 1 步的遍历过程中，插入递归进行实现

  > 注意： 
  >
  > - 先确定**递归结束的条件**，例如本题中可设 begin == str.size() - 1
  >
  > - 形如 **aba** 或 **aa** 等特殊情况，需要自行控制
  >
  > - 输出的排列可能**不按字典顺序排列**，需要自行排序

- **代码**： 

  ```java
  import java.util.*;
  
  public class Solution {
      public ArrayList<String> Permutation(String str) {
          ArrayList<String> list = new ArrayList<String>();
          if(str!=null && str.length()>0){
              PermutationHelper(str.toCharArray(),0,list);
              Collections.sort(list);
          }
          return list;
      }
       
      private void PermutationHelper(char[] chars,int i,ArrayList<String> list){
          if(i == chars.length - 1){
              String str = String.valueOf(chars);
              if(!list.contains(str)){
                  list.add(str);
              }
          }else{
              for(int j = i;j < chars.length;j++){
                  swap(chars,i,j);
                  PermutationHelper(chars,i + 1,list);
                  swap(chars,i,j);
              }
          }
      }
       
      private void swap(char[] chars,int i,int j){
          char tmp = chars[i];
          chars[i] = chars[j];
          chars[j] = tmp;
      }
  }
  ```

### 2. 字典序实现

推荐阅读： [字典序全排列算法研究](https://www.cnblogs.com/pmars/p/3458289.html) 

- **思路**： 

  > 如何得到 346987521 的下一个：
  >
  > 1. 从尾部往前找第一个 P(i-1) < P(i) 的位置： `3 4 6 <- 9 <- 8 <- 7 <- 5 <- 2 <- 1`
  >
  >    > 最终找到 6 是第一个变小的数字，记录下 6 的位置 i-1
  >
  > 2. 从i位置往后找到最后一个大于6的数： `3 4 6 -> 9 -> 8 -> 7 5 2 1`
  >
  >    > 最终找到7的位置，记录位置为 m
  >
  > 3. 交换位置 i-1 和 m 的值： `3 4 7 9 8 6 5 2 1`
  >
  > 4. 倒序 i 位置后的所有数据：`3 4 7 1 2 5 6 8 9`
  >
  > 则 347125689 为 346987521 的下一个排列

- **代码**： 

  ```java
  public ArrayList<String> Permutation2(String str){
      ArrayList<String> list = new ArrayList<String>();
      if(str == null || str.length() == 0){
          return list;
      }
      char[] chars = str.toCharArray();
      Arrays.sort(chars);
      list.add(String.valueOf(chars));
      int len = chars.length;
      while(true){
          int lIndex = len - 1;
          int rIndex;
          while(lIndex >= 1 && chars[lIndex - 1] >= chars[lIndex]){
              lIndex--;
          }
          if(lIndex == 0)
              break;
          rIndex = lIndex;
          while(rIndex < len && chars[rIndex] > chars[lIndex - 1]){
              rIndex++;
          }
          swap(chars,lIndex - 1,rIndex - 1);
          reverse(chars,lIndex);
          list.add(String.valueOf(chars));
      }
      return list;
  }
  
  private void reverse(char[] chars,int k){
      if(chars == null || chars.length <= k)
          return;
      int len = chars.length;
      for(int i = 0;i < (len - k) / 2;i++){
          int m = k + i;
          int n = len - 1 - i;
          if(m <= n){
              swap(chars,m,n);
          }
      }
  }
  
  private void swap(char[] cs,int i,int j){
      char temp = cs[i];
      cs[i] = cs[j];
      cs[j] = temp;
  }
  ```

# 三、分治策略

## 1. 最大子数组

### 1. 详解

用分治法求出其最大的子数组，首先将数组划分为两个规模尽量相等的子数组，找到数组的中央位置，比如mid，然后考虑求解两个子数组A[low..mid]和A[mid+1..high]

那么子数组A[i..j]所有的情况都逃脱不了一下三种：

- 完全位于子数组A[low..mid]中，**low<=i<=j<=mid**
- 完全位于子数组A[mid+1..high]中，**mid<i<=j<=high**
- 跨越了中点，因此 **low<=i<=mid<j<=high**

**求跨越中点的伪代码：**

```c
FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high){
	left_sum = 负无穷
	sum = 0
	for i = mid downto low //从中间点往左遍历
		sum = sum + A[i]
		if sum > left_sum
			left_sum = sum //记录中间点左边最大值
			max_left = i
	right_sum = 负无穷
	sum = 0
	for j = mid + 1 to high //从中间点往右遍历
		sum = sum + A[j]
		if sum > right_sum
			right_sum = sum //记录中间点右边最大值
			max_right = j
	return (max_left,max_right,left_sum + right_sum)
}
```

**主的递归伪代码：**

```c
FIND-MAXIMUM-SUBARRAY(A,low,high){
	if high == low
		return (low,high,A[low])
	else 
		mid = (low + high) / 2
        //递归分治求解左右子数组最大值
		(left_low,left_high,left_sum) = FIND-MAXIMUM-SUBARRAY(A,low,mid)
		(right_low,right_high,right_sum) = FIND-MAXIMUM-SUBARRAY(A,mid + 1,high)
        //求解跨越中间点的最大值
		(cross_low,cross_high,cross_sum) = FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)
		if left_sum >= right_sum and left_sum >= cross_sum
			return (left_low,left_high,left_sum)
		else if right_sum >= left_sum and right_sum >= cross_sum
			return (right_low,right_high,right_sum)
		else 
			return (cross_low,cross_high,cross_sum)
}
```

### 2. 时间复杂度

**T(n) 递归式：**

$$T(n) = \begin{cases}\theta(1) & \text if &n = 1 \\2 * T(n/2) + \theta(n) & \text if & n > 1\end{cases}$$

**时间复杂度：**	

$$T(n) = n * logn$$

### 3. 非递归，线性时间实现

```java
public static int findMaxByLine(int[] array) {
    int max = Integer.MIN_VALUE;
    int tmp = Integer.MIN_VALUE;
    for (int i = 0; i < array.length; i++) {
        if (tmp + array[i] >= array[i]){
            tmp += array[i];
        }else {
            tmp = array[i];
        }
        if (tmp > max){
            max = tmp;
        }
    }
    return max;
}
```

## 2. 矩阵乘法的 Strassen

### 1. 伪代码 

```c
//数学方法
SQUARE-MATRIX-MULTIPLY(A,B){
	m = A.rows
	let C be a new nXn matrix
	for i = 1 to n
		for j = 1 to n
			C[i][j] = 0
			for k = 1 to n
				C[i][j] = C[i][j] + A[i][k] * B[k][j]
	return C
 }
```

//**分治法**

![](../../pics/alg/alg_1.png)

### 2. 详解

**伪代码反正我是没看懂，建议看看书P45-47 的讲解吧（表示不一定能看懂，难受）**

### 3. 时间复杂度

**T(n) 递归式：**

$$T(n) = \begin{cases}\theta(1) & \text if & n = 1 \\7 * T(n) + \theta(n^2) & \text if & n > 1   \end{cases}$$

时间复杂度：

$$T(n) = \theta(n^{lg7})$$

## 3. 大整数相乘

### 1. 伪代码

```c
MULT(X,Y){
	if |X| = |Y| = 1 
		then do return XY
	else 
		return MULT(a, c)*2^n + (MULT(a, d) + MULT(b,c))2^(n / 2) + MULT(b, d)
}
```

### 2. 详解

- 假如有两个n位的M进制大整数x，y，利用一个小于n的正数k（通常k的取值为n/2左右），将x，y分解成如下形式：$x = a *  10 ^ {n/2} + ；y = c * 10 ^ {n/2} + d$
- 则，x，y的乘积可计算为：$x * y = a * c * 10^n + (a * d + b * c) * 10^{n/2} + b * d$

### 3. 时间复杂度

​	$$T(n) = \begin{cases}1 & \text if &n = 1 \\4 * T(n/2) + \theta(n) & \text if & n > 1\end{cases}$$

​	$$T(n) = \theta(n^2)$$ 

## 4. Karatsuba 算法

### 1. 伪代码

```c
//思路参考，并非真的伪代码
MULT(X,Y){
	if |X| = |Y| = 1 
		then do return X * Y
	else
		A1 = MULT(a,c);
		A2 = MULT(b,d);
		A3 = MULT((a+b)(c+d));
}
```

### 2. 详解

![](../../pics/alg/alg_3_1.png)

### 3. 时间复杂度

​	$$T(n) = \begin{cases}1 & \text if &n = 1 \\3 * T(n/2) + \theta(n) & \text if & n > 1\end{cases}$$

​	$$T(n) = \theta(n ^ {log_23}) = \theta(n ^ {1.58})$$	 

## 5. 最近点对问题

### 1. 详解

- **划分阶段：** 用一条垂直线 L 把 S 划分成两个尽可能大小接近的子集 $S_L$、$S_R$ ，$S_L$ 与 $S_R$ 分别包含 n/2 个点，分别**计算出 $S_L$ 、$S_R$ 中的最近点对距离 $δ_L$ 、$δ_R$** ，再计算 $S_L$ 的点与 $S_R$ 的点之间的最小距离 $δ’$ 

- **治理阶段(求  $δ’$ )：** 设 $δ=min\{δ_L，δ_R\}$，删除所有到 L 的距离大于 δ 的点，只剩在下图中的灰色部分 $T$ ![](../../pics/alg/alg_3_2.png)

  > **T 中的每个点最多需要和 T 中的7个点进行比较** 
  >
  > 原因：
  >
  > - 划分出 $δ*2δ$ 的矩形
  > - 如果该矩形内任意两点之间的距离不超过 δ，这个矩形最多能容纳8个点，其中至多4个点属于 $S_L$ ，至多4个点属于 $S_R$ 
  > - 但有两个点分别在矩形上下边的中点时，可以取得最大点数
  > - 因此最多只需要比较7次
  >
  > **将 T 中的点按 y 轴坐标的增序排列，遍历所有点，但每次只计算某一点和它上面7个点的距离**

  ![](../../pics/alg/alg_3_4.png)

- **组合阶段：** $δ=min\{δ_L，δ_R，δ’ \}$ 

### 2. 时间复杂度

递归表达式：

$$T(N)=2T(N/2)+O(N) $$

时间复杂度：

$$T(n) = O(n * logn)$$

### 3. 伪代码(仅供参考)

![](../../pics/alg/alg_3_5.png)

## 6. 递归式求解的三种方法

### 1. 主方法求解递归式

 **递归式：** $T(n) = a * T(n/b) + f(n)$ **其中 a>=1，b>1，f(n)是给定的函数，T(n)是定义在非负整数上的递归式**



![](../../pics/alg/alg_3_6.png)

> **将 f(n) 于函数 $n^{log_ba}$ 进行比较：**
>
> - **若函数 $n^{log_ba}$  更大，则解为 $T(n) = \theta(n^{logba})$**
> - **若函数 f(n) 更大，则解为 $T(n) = \theta(f(n))$**
> - **若两个函数相当，则解为 $T(n) = \theta(n^{log_ba} * lgn) = \theta(f(n) * lgn)$**

**例子：**

对于 $T(n) = 9 * T(n/3) + n$ ，可得 a = 9，b = 3，f(n) = n

因此 $n^{log_ba} = n^{log_39} = n^2$ ，而 $f(n) = n <  n^2$ ，所以解为 $T(n) = \theta(n^{log_ba}) = \theta(n^2)$ 

### 2. 递归树求解

> - **用主方法求解不了的递归式，可以用递归树来猜测解的上界，然后用代入法来证明解的正确性**
> - **递归树的求解精确度取决于你画递归树的精确度**

**例子：**

$T(n) = 3 * T(n/4) + \theta(n^2)$ 的递归树 

![](../../pics/alg/alg_3_7.png)

![](../../pics/alg/alg_3_8.png)

![](../../pics/alg/alg_3_9.png)

> **把递归树扩展到 T(1) 的层，然后以 T(1) 为单位把每层的代价求和，最后就是总的代价**

### 3. 代入法

- **猜测解的形式**
- **用数学归纳法求出解中方的常数，并证明是正确的**

**例子：**

递归式 $T(n) = 2T(n/2)+n$ 

- 猜测解是 O(nlgn) ，我们要寻找到一个常数c,使得 $T(n)<=cnlgn$ 
- 即 $T(n) <= 2c(n/2)lg(n/2)+n <= cnlgn-cnlg2+n = cnlgn-cn+n<= cnlgn $ 
- 只要 c>=1，则T(n)<=cnlgn，所以我们的猜测是正确的

>  **注意：**
>
> - **代入法全凭经验**
> - **通常用递归树来确定上界，然后用代入法再证明**

# 三、随机算法***

- [算法导论第五章：概率分析和随机算法](https://blog.csdn.net/longhuihu/article/details/5864442) 

## 1. 随机数



## 2. 数值概率算法





# 四、统计算法

## 1. 求最大最小值

#### 1. 伪代码

```c
//求最小值：时间复杂度为 n - 1
Minimum(A)
	min ← A[1]
	for i = 2..n
		do if A[ i ] < min
			then min ← A[ i ]
	return min
//同时求最大最小值: 时间复杂度为 3n/2 - 2
Min-Max(A)
	for i = 1..n/2
	do if A[2i – 1] ≤ A[2i] //分治的思想，将数组分成存小数和大数的两个数组
		then B[i] ← A[2i – 1]
		C[i] ← A[2i]
	else B[i] ← A[2i]
		 C[i] ← A[2i – 1]
	min ← Minimum(B) //求小数组中的最小数
	max ← Maximum(C) //求大数组中的最大数
	return (min, max) 
```

#### 2. 详解

根据伪代码的步骤理解即可

## 2. 随机选择算法

### 1. 期望为线性时间的选择算法

#### 1. 伪代码

```c
//返回数组中第 i 小的元素
RANDOMIZED-SELECT(A, p, r, i )
	if p == r
		then return A[p]
	q ←RANDOMIZED-PARTITION(A, p, r) //返回一个随机主元，随机快速排序中的算法：二.7.1
	k ← q - p + 1 //(分割中心所在位置)，比 A[q] 元素小的个数
	if i == k //判断 i 与 k 的大小,若相等，即A[q]为第 i 小，返回A[q] 
		then return A[q]
	else if i < k
		then return RANDOMIZED-SELECT(A, p, q-1, i ) //若i < k,则所需元素落在划分的低区
	else return RANDOMIZED-SELECT(A, q + 1, r, i-k) //若i > k,则所需元素落在划分的高区
```

#### 2. 详解（参照伪代码）

- 调用q=Randomized_Partition(A,p,r) **随机返回一个主元**，在数组[p,r]中**第  q-p 小**（q 左边元素都比q所在值小）
- **k=q-p+1 为比A[q]元素小的个数（包括本身）** 
- 判断 i 与 k 的大小,若相等，即A[q]为第 i 小，返回A[q] 
- 若i < k,则所需元素落在划分的低区 递归调用 Randomized_Select(A,p,q-1,i) 
- 若i > k,则所需元素落在划分的高区 因为已经知道有k个值小于第 i 小的元素，则递归调用 Randomized_Select(A,q+1,r,i-k)

> 可以理解为不断使用**二分算法**，先通过随机快排将元素分成两组，然后判断在哪一组，在再二分

### 2. 最坏情况为线性时间的选择算法

**详解：**

- 将输入数组的n个元素**划分为 n/5 组**，每组5个元素，且至多只有一组由剩下的n mod 5个元素组成
- 首先对每组元素进行插入排序，然后**确定每组有序元素的中位数**
- 递归调用Select()，**找出上述所有组中位数的中位数**，若为偶数个，可以约定用哪一个
- 调用 Partition(int *A,int p,int r,int x)（**二.6.1 快排的修订版，x为上一步中的中位数的中位数**）令 k 比低区元素数目多1，因此 x 为第 k 小的元素，并且有 n - k 个元素划分在高区

> **上述步骤为寻找主元**（采用了分治的思想，将数组元素划分为5个小数组，降低了运算复杂度），可以结合参照上面的伪代码，更容易理解

- **若 i == k ,返回 x ,如果i < k,则在低区递归调用Select()，若 i > k ，则在高区递归查找第i -k小的元素**（同上伪代码的递归调用）

# 五、动态规划

## 1. 概念

- **采用动态规划的前提：具有最优子结构和重叠子问题的性质**
- **动态规划是通过组合子问题的解而解决整个问题的**
- **动态规划算法对每个子问题只求解一次，将其结果存放到一张表中，以供后面的子问题参考，从而避免每次遇到各个子问题时重新计算答案**
- **动态规划通常用于最优化问题**

**步骤：**

- **描述最优解的结构**
- **递归定义最优解的值**
- **按<u>自底向上</u>的方式计算最优解的值**
- **由计算出的结果构造一个最优解**

## 2. 装配线调度问题

### 1. 伪代码



![](../../pics/alg/alg_2.png)

### 2. 详解

**根据伪代码一步一步来**（下图深颜色箭头有问题）：

**以第一步为例：**

- 首先令 $f_1[1] = e_1 + S_{1,1} = 2 + 7 = 9, f_2[1] = e_2 + S_{2,1} = 4 + 8 = 12$
- **求 $f_1[2]$：** 
  - 因为 9 + 9 < 12 + 2 + 9($f_1[1] + S_{1,2} < f_2[1] + t_{2,2} + S_{1,2}$)，所以  $f_1[2]$ 取 18，$l_1[2] = 1$ 
- 求 $f_2[2]$： 
  - 因为 9 + 2 + 5 < 12 + 5($f_1[1] + t_{1,2} + S_{2,2} < f_2[1] + S_{2,2}$)，所以 $f_2[2]$ 取 16，$l_2[2] = 1$

**经过的各个节点：** 

`7-->5-->3-->4-->5-->4-->end` 

![](../../pics/alg/alg_5_1.png)

### 3. 递归表达式

$$f_1[j] = \begin{cases} e_1 + a_{1,1} & \text if & j = 1 \\ min(f_1[j - 1] + a_{1,j},f_2[j - 1] + t_{2,j - 1} + a_{1,j})   & \text if & j > 1\end{cases}$$

$$f_2[j] = \begin{cases} e_2 + a_{2,1} & \text if & j = 1 \\ min(f_2[j - 1] + a_{2,j},f_1[j - 1] + t_{1,j - 1} + a_{2,j})  & \text if & j > 1\end{cases}$$

$$f^* = min(f_1[n] + x_1,f_2[n] + x_2)$$

## 3. 钢条切割

- **问题描述：** 给定一段长度为n英寸的钢条和一个价格表 $p_i(i=1,2,…n)$,求切割钢条方案,使得销售收益最大

  > **注意：** 如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割

![](../../pics/alg/alg_5_2.png) 

### 1. 自顶向下递归实现	

#### 1. 伪代码

```c
//自顶向下递归实现
CUT-ROD(p,n)//p 为价格表，n 为长度
	if n == 0
		return 0
	q = -1//q 为收益
	for i = 1 to n
		q = max(q,p[i] + CUT-ROD(p,n - i))
	return q
```

#### 2. 详解

当 n = 4时，递归调用树如下：

![](../../pics/alg/alg_5_3.png)

#### 3. 时间复杂度

**表达式：**

$$T(n) = 1 + \sum_{i=1}^{n - 1}{T(i)}$$

**时间复杂度：**

$$T(n) = 2^n$$

### 2. 带备忘的自顶向下法	

#### 1. 伪代码

```c
//带备忘的自顶向下法	
MEMOIZED-CUT-ROD(p,n)
	let r[0..n] be a new array
	for i = 0 to n
		r[i] = -1
	return MEMOIZED-CUT-ROD-AUX(p,n,r)

MEMOIZED-CUT-ROD-AUX(p,n,r)
	if r[n] >= 0
		return r[n] //如果有保存的值，直接返回
	if n == 0
		q = 0
	else //没有保存，进行计算
		q = -1
		for i = 1 to n
			q = max(q,p[i] + MEMOIZED-CUT-ROD-AUX(p,n - i,r))
	r[n] = q //将值保存
	return q
```

#### 2. 详解

- 仍按自然的递归形式编写过程，但过程会**保存每个子问题的解**（通常保存在一个数组或散列表中）
- 当需要一个子问题的解时，过程**首先检查是否已经保存过此解**；如果是，则直接返回保存的值，从而节省了计算时间；否则，按通常方式计算这个子问题

#### 3. 时间复杂度

​	$$T(n) = \theta(n^2)$$

### 3. 自底向上法

#### 1. 伪代码

```c
//自底向上法
BOTTOM-UP-CUT-ROD(p,n)
	let r[0..n] be a new array
	r[0] = 0
	for j = 1 to n
		q = -1
		for i = 1 to j
			q = max(q,p[i] + r[j - i])
		r[j] = q //将子问题的解保存
	return r[n]
```

#### 2. 详解(看懂伪代码)

- 恰当定义子问题“规模”的概念，**使得任何子问题的求解都只依赖于“更小的”子问题的求解**
- 将子问题按照规模顺序，由小至大顺序进行求解
- 当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存
- 每个子问题只需求解一次，当我们求解它时，它的所有前提子问题都已求解完成

#### 3. 时间复杂度

> 该算法的递归调用迭代次数是一个**等差数列**

​	$$T(n) = \theta(n^2)$$

#### 4. 重构解 

```c
//重构解：不仅保存最优收益值，还保存对应的切割方案
EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
	let r[0..n] and s[0..n] be new arrays
	r[0] = 0
	for j = 1 to n
		q = -1
		for i = 1 to j
			if q < p[i] + r[j - i]
				q = p[i] + r[j - i]
				s[j] = i //保存切割方案
		r[j] = q //保存最优收益
	return r and s
```

## 4. 矩阵链乘法

### 1. 伪代码

```c
MAXTRIX_CHAIN_ORDER(p)
	n = p.length-1
	let m[1..n,1..n] and s[1..n-1,2..n] be new tables
	for i=1 to n 
		do m[i][i] = 0
	for l = 2 to n  //j 从 2 开始取值（下图中对应的 j）
		for i=1 to n-l+1 //i 从 1 开始取值（下图中对应的 i）
			j=i+l-1
			m[i][j] = MAXLIMIT
			for k=i to j-1 //计算可能存在的矩阵乘法种类
				q = m[i][k] + m[k+1][j] + p(i-1)p(k)p(j) //计算
				if q < m[i][j]
					then m[i][j] = q //保存各结果最小值
					s[i][j] = k	//保存取最小结果时，与哪个矩阵相乘
	return m and s
```

### 2. 详解（仅供参考，看实例）

- **问题描述：** 给定n个矩阵的链< A1, A2, …, An>，矩阵$A_i$ 的规模为 $p_{i-1}$  × $P_i$，求完全括号化方案，使得计算乘积A1A2…An所需的乘法次数最少

- **最优括号化方案的结构特征：** $A_{i..j}$ 表示 $A_iA_{i+1}....A_j$ 乘积的结果矩阵，对某个整数 k，先计算 $A_{i..k}$ 和 $A_{k+1..j}$ ，然后再递归求解

- **一个递归解**： 设 **m[i,j]为计算机矩阵 $A_{i...j}$ 所需的标量乘法运算次数的最小值**，对计算 $A_{1...n}$ 的最小代价就是m[1,n]；**s[i,j] 保存 $A_iA_{i+1}....A_j$ 最优括号化方案的分割点位置 k** 

  分两种情况进行讨论如下：

  - **当i==j时：** **m[i,j] = 0** 
  - **当i<j 时：m[i,j] ＝min{m[i,k]+m[k+1,j]+$p_{i-1}p_kp_j$} (i≤k<j)** 

- **计算最优代价：** 采用自底向上表格法逐级记录

- **构造一个最优解**： 上步中已经计算出来最小代价，并保存了相关的记录信息。因此只需对s表格进行递归调用展开既可以得到一个最优解

  ```c
  PRINT_OPTIMAL_PARENS(s,i,j)
    if i== j 
       then print "A_i"
    else
       print "(";
       PRINT_OPTIMAL_PARENS(s,i,s[i][j]);
       PRINT_OPTIMAL_PARENS(s,s[i][j]+1,j);
       print")";
  ```

**实例：（看懂这个就ok，可以考虑理解一下伪代码）**

![](../../pics/alg/alg_5_5.png) 

![](../../pics/alg/alg_5_4.png)

**一步一步计算：** （动手算一下）

- 首先计算最下面的结果

  > **如：$A_{12}$ --> i = 1,j = 2 <==> 30 X 35 X 15;  $A_{23}$ --> i = 2,j = 3 <==> 35 X 15 X 5 等等**

- 然后再计算上面一行的值，如：**$A_{13}$ --> i = 1,j = 3 有两种可能 $A_1$ * $A_{23}$ 或 $A_{12} * A_3$ ，取两者最小值**

### 3. 时间复杂度

**递归式：**

$$m[i,j] = \begin{cases} 0 & \text if & i = j \\min_{i<=k<j}(m[i,k] + m[k+1,j]+p_{i-1}p_kp_j) & \text if & i < j \end{cases}$$

**时间复杂度：**

$$T(n) = O(n^3)$$

## 5. 最长公同子序列

### 1. 伪代码

```c
LCS-Length(X,Y)
	m = X.length
	n = Y.length
	let b[1..m,1..n] and c[0..m,0..n] be new tables
	for i = 1 to m
		c[i 0] = 0
	for j = 0 to n
		c[0,j] = 0
	for i = 1 to m
		for j = 1 to n
			if x(i) = y(j)
				c[i, j] = c[i-1, j-1]+1  //相等时：取左上角值 + 1
				b[i, j] = “ 左上箭头”
			else if c[i-1,j] >= c[i, j-1] //上方值比左边值大时：取上方值
				c[i,j] = c[i-1, j]		
				b[i, j] = "向上箭头"
			else c[i, j] = c[i, j-1]	//左边值比上方值大时：取左边值
				b[i, j] = "向左箭头"
	return c and b
```

### 2. 详解

**描述：返回两个字符串的最长公共子序列的长度**

- 描述最优解的结构

- 递归定义最优解的值：**c[i,j] 表示 $X_i 和 Y_i$  的 LCS 长度** 

  $$c[i,j] = \begin{cases} 0 & \text if &i = 0 或 j = 0 \\c[i - 1,j - 1] + 1 & \text if & i,j > 0 且 x_i = y_i \\max(c[i,j - 1],c[i - 1,j]) & \text if & i,j > 0 且 x_i != y_i \end{cases}$$

- 计算 LCS 长度

- 构造 LCS

---

**一步一步计算右下角图（结合上面的伪代码）：** 

> **最终结果：跟着深色部分箭头从右下往左上走**，即：BCBA

![](../../pics/alg/alg_5_6.png)

### 3. 时间复杂度

​	$$T(n) = \theta(m * n)$$

## 6. 最优二叉搜索树

### 1. 伪代码

```c
OPTIMAL-BST(p, q, n)
    let e[],w[],root[] be new tables
    for i = 1 to n + 1	//初始化 e 和 w 表格对角线处的初始概率
        e[i,i - 1] = q_(i-1)
        w[i,i - 1] = q_(i - 1)
    for l = 1 to n	//对所有节点遍历
    	for i = 1 to n - l + 1	//遍历 i 节点对应的 j 节点（对应图中的 i 和 j）
            j = i + l - 1
            e[i,j] = 正无穷
            //注意：下面提到的表格，都是未旋转的表格
            w[i,j] = w[i,j - 1] + p_j + q_j //w 表格中，左边一位（j 小一位）+ p + q 值 
            for r = i to j
            	//e 表格中，左边(j 小 r+1 位) + 下面（i 大 r-1 位） + w[i,j] 值
            	t = e[i,r - 1] + e[r + 1,j] + w[i,j] 
            	if t < e[i,j]
            		e[i,j] = t //取小的值
            		root[i,j] = r //保存根节点 k_r 的下标 r
    return e and root
```

//**下图作为参照：**

![](../../pics/alg/alg_3.png)

### 2. 详解

![](../../pics/alg/alg_5_9.png)

**根据上图(a)可以逐点计算期望搜索代价：** 

> 二叉树搜索树中搜索一个关键字需要访问的结点数等于包含关键字的结点的深度加1

![](../../pics/alg/alg_5_10.png)

> ****

**最优二叉搜索树：期望代价最小的二叉搜索树** 

**步骤：** 

- 描述最优解的结构

- 递归定义最优解的值：**e[i,j] 表示在包含关键字 $k_i，... ，k_j$ 的最优二叉搜索树中进行一次搜索的期望代价；root[i,j] 保存根节点 $k_r$  的下标 r**

  ![](../../pics/alg/alg_5_7.png)

  ​			$$w[i,j] = \begin{cases}q_{i-1} & \text if & j = i - 1 \\w[i,j - 1] + p_j + q_j & \text if & i != j - 1 \end{cases}$$

- 按自底而上的方式计算最优解的值

- 由计算出的结果创造一个最优解

**根据伪代码一步一步计算（同5.4 5.5 的计算方法）：**

![](../../pics/alg/alg_5_11.png)

根据上图，**对一个 n = 5 的关键字集合计算其最优二叉搜索树：** （**伪代码步骤注解**）

![](../../pics/alg/alg_5_8.png)

**问题：如何根据 root[i,j] 的结果构造出二叉搜索树？P230——15.5-1**

### 3. 时间复杂度

​	$$T(n) = O(n^3)$$

# 六、贪婪算法

## 1. 概述

- **贪心选择性质：** 若一个问题的全局最优解可以通过局部最优解来得到，则说明该问题具有贪心选择性质

- **优化子结构：** 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质

- 该算法**存在问题：** 

  - 不能保证求得的最后解是最佳的
  - 不能用来求最大或最小解问题
  - 只能求满足某些约束条件的可行解的范围

- 实现该**算法的过程：** 

  >  从问题的某一初始解出发
  >
  >  while 能朝给定总目标前进一步 do 
  >
  >  ​	求出可行解的一个解元素 
  >
  >  由所有解元素组合成问题的一个可行解

- 贪心算法和动态规划的**区别：** 

  -  **贪心算法是自顶向下的，而动态规划则是自底向上的**
  - **贪婪算法总是找当前最大值，动态规划则是根据子问题的比较找最优解的值**

## 2. 作业(活动)选择问题

### 1. 描述

> - 对n个作业进行排程，这些作业在执行期间需要专用某个共同的资源
> - **选出最多个不冲突的作业**

![](../../pics/alg/alg_6_1.png) 

### 2. 递归求解

#### 1. 伪代码

```c
//***********活动编号已经按结束时间排序**********
//递归
REC-ACT-SEL (s, f, k, n)
	m ← i + 1
	while m ≤ n and s[m] < f[k] //find the first activity in S(k) to finish
		do m ← m + 1
	if m ≤ n
		then return {a(m)} and REC-ACT-SEL(s, f, m, n)
	else return null
```

#### 2. 详解

> **P239 定理16.1 的定理证明**

如上述伪代码所示

#### 3. 时间复杂度

**递归式：**

$$c[i,j] = \begin{cases}0 & \text if & S_{i,j} = \phi \\max(c[i,k] + c[k,j] + 1) & \text if & S_{i,j} \neq \phi \end{cases}$$

**时间复杂度：**

$$T(n) = \theta(n)$$

### 3. 迭代求解

#### 1. 伪代码

```c
//***********活动编号已经按结束时间排序**********
//迭代
GREEDY-ACTIVITY-SELECTOR(s, f)
	n = s.length
	A ← {a1}
	k ← 1
	for m ← 2 to n
		do if s[m] ≥ f[k]  //activity a(m) is compatible with a(k)
			then A ← A and {a(m)}
			k ← m // a(i) is most recent addition to A
	return A
```

#### 2. 详解

如上述伪代码所示

#### 3. 时间复杂度

​	$$T(n) = \theta(n)$$

## 3. Huffman 编码

### 1. 伪代码(仅供参考)

```c
HUFFMAN(C)
	n = |C|
	Q = C
	for i = 1 to n – 1
		do allocate a new node z
		z.left = x = EXTRACT-MIN(Q)
		z.right = y = EXTRACT-MIN(Q)
		z.freq = x.freq + y.freq
		INSERT (Q, z)
	return EXTRACT-MIN(Q)
```

### 2. 详解

![](../../pics/alg/alg_6_3.png)

![](../../pics/alg/alg_6_4.png)

![](../../pics/alg/alg_6_5.png)

### 3. 时间复杂度

​	$$T(n)=O(n∗logn)$$

### 4. 哈夫曼编码

左图为构造哈夫曼树的过程的权值显示。右图为将权值左分支改为0，右分支改为1后的哈夫曼树： 

![](../../pics/alg/alg_6_6.png)

对这六个字母用其从树根到叶子所经过的路径的0或1来编码，可以得到下表：

![](../../pics/alg/alg_6_7.png)

![](../../pics/alg/alg_6_8.png)

## 4. 0/1背包问题与部分背包问题

### 1. 描述 

> 给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高
>

### 2. 详解

- 利用动态规划思想 ，子问题为：$f[i][v]$ 表示前 i 件物品恰放入一个容量为v的背包可以获得的最大价值

- 状态转移方程是：**$f[i][v]=max(f[i-1][v],f[i-1][v-c[i]]+w[i])$**     //**这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的**

  > 如果只考虑第i件物品放或者不放，那么就可以转化为只涉及前i-1件物品的问题
  >
  > - 1、如果**不放第 i 件物品**，则问题转化为“**前i-1件物品放入容量为v的背包中**”
  > - 2、如果**放第 i 件物品**，则问题转化为“**前i-1件物品放入剩下的容量为v-c[i]的背包中”(此时能获得的最大价值就是 $f [i-1][v-c[i]]$ 再加上通过放入第i件物品获得的价值w[i]**)，则 $f[i][v]$ 的值就是1、2中最大的那个值

- **初始化的细节问题：**

  - 要求“**恰好装满背包**”时的最优解
  - 求**小于等于背包容量的最优解**，即不一定恰好装满背包

---

**根据物品是否可以分割**，分为两类背包问题：

- 如果物品不可以分割，称为 **0—1 背包问题（动态规划）**
- 如果物品可以分割，则称为 **部分背包问题（贪心算法）**

有3种方法来选取物品：

- 当作 0—1 背包问题，用动态规划算法，获得最优值 220
- 当作 0—1 背包问题，用贪心算法，按性价比从高到底顺序选取物品，获得最优值 160。由于物品不可分割，剩下的空间白白浪费
- 当作部分背包问题，用贪心算法，按性价比从高到底的顺序选取物品，获得最优值 240。由于物品可以分割，剩下的空间装入物品 3 的一部分，而获得了更好的性能

![](../../pics/alg/alg_6_2.png)

### 3. 时间复杂度

​	$$T(n) = O(N * V)$$

### 4. 实现

三种贪心思想：

- 选择价值最大的物品

- 选择重量最轻的物品
- 选择单位重量价值最大的物品

> 选择第三种策略： 先把性价比最高的全部装入，最后不足全部装入的部分装入

```java
public static int greedy_knapSack(int[] w,int[] v,int n,int c){
    //  假设物品已按单位重量降序排列
    double[] x = new double[10];
    int maxValue = 0;
    int i;
    for(i = 0;w[i] < c;i++){
        x[i] = 1; //将物品 i 装入背包
        maxValue += v[i];
        c = c - w[i]; // 背包剩余数量
    }
    x[i] = (double)c/w[i];    //物品i装入一部分
    maxValue += x[i]*v[i];
    return maxValue;    //返回背包获得的价值
}
```

# 七、图算法

## 1. 基本图算法

### 1. 广度优先搜索(BFS)

#### 1. 伪代码

```c
BFS(G,s)
	for each vertex u 属于 G.V - {S}
		u.color = WHITE
		u.d = 无穷
		u.pi = NIL
	s.color = GRAY
	s.d = 0
	s.pi = NIL
	Q = null
	ENQUEUE(Q,s) 
	while Q != null
		u = DEQUEUE(Q)
		for each v 属于 G.Adj[u]
			if v.color == WHITE
				v.color = GRAY
				v.d = u.d + 1
				v.pi = u
				ENQUEUE(Q,v)
		u.color = BLACK
```

#### 2. 详解

> 从临近源顶点s最近的顶点开始，通过对图G的边的探索发现从源顶点s能够抵达的每个顶点

![](../../pics/alg/alg_7_1.png)

#### 3. 时间复杂度

​	$$T(n)=O(V+E)$$

### 2. 深度优先搜索(DFS)

#### 1. 伪代码

```c
DFS(G)
	for each vertex u 属于 G.V
		u.color = WHITE
		u.pi = NIL
	time = 0
	for each vertex u 属于 G.V
		if u.color == WHITE
			DFS-VISIT(G,u)

DFS-VISIT(G,u)
	time = time + 1	//white vertex u has just been discovered
	u.d = time
	u.color = GRAY
	for each v 属于 G:Adj[u]
		if v.color == WHITE 
			v.pi = u
			DFS-VISIT(G,v)
	u.color = BLACK		//blacken u;it is finished
	time = time + 1
	u.f = time
```

#### 2. 详解

> 从当前访问顶点开始，探索图的边以发现图中的每个顶点

![](../../pics/alg/alg_7_2.png)

#### 3. 时间复杂度

​	$$T(n)=θ(V+E)$$

### 3. 拓扑排序

#### 1. 伪代码

```c
//对有向无环图
TOPOLOGICAL-SORT(G)
	call DFS(G) to compute finish times v.f for each vertex v
	as each vertex is finished,insert it onto the front of a linked list
	return the link list of vertices
```

#### 2. 详解

> 找出有向无回路图G = (V, E) 中顶点的一个线性序，使得(u, v)如果是图中的一条边，那么在这个线性序中u在v前出现(如果 G 包含环路，可能就有多个解)

**步骤(很重要)**： 

- **在有向图中选一个没有前驱的顶点并且输出**

- **从图中删除该顶点和所有和它有关的边**

- **重复上述两步，直至所有顶点输出**

  >  或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的，因此，也**可以通过拓扑排序来判断一个图是否有环**

![](../../pics/alg/alg_7_3.png)

该图的拓扑排序为： `v6 –-> v1--> v4 --> v3 --> v5 --> v2` 

#### 3. 时间复杂度

​	$$T(n)=θ(V+E)$$

### 4. 强连通分支

#### 1. 伪代码(参考)

```c
STRONGLY-CONNECTED-COMPONENTS(G)
	call DFS(G) to compute finishing times u.f for each vertex u
	compute G^T
	call DFS(G^T),but in the main loop of DFS,consider the vertices
		in order of decreasing u.f(as computed in line 1)
	output the vertices of each tree in the depth-first forest formed in line 3 as a separate strongly connected component
```

#### 2. 相关概念

- **割点：** 若删掉某点后，原连通图分裂为多个子图，则称该点为割点

- **割点集合：** 在一个无向连通图中，如果有一个顶点集合，删除这个顶点集合，以及这个集合中所有顶点相关联的边以后，原图变成多个连通块，就称这个点集为割点集合

- **点连通度：** 最小割点集合中的顶点数

- **割边(桥)：** 删掉它之后，图必然会分裂为两个或两个以上的子图

- **割边集合：** 如果有一个边集合，删除这个边集合以后，原图变成多个连通块，就称这个点集为割边集合

- **边连通度：** 一个图的边连通度的定义为，**最小割边集合中的边数**

- **缩点：** 把没有割边的连通子图缩为一个点，此时满足**任意两点之间都有两条路径可达**

- **双连通分量：** 分为**点双连通和边双连通**，满足任意两点之间，能通过两条或两条以上没有任何重复边的路到达的图称为双连通图

  > - **点连通度大于1的图称为点双连通图**
  > - **边连通度大于1的图称为边双连通图**
  > - **无向图G的极大双连通子图称为双连通分量** 

---

- **强连通图**： 在一个强连通图中，**任意两个点都通过一定路径互相连通**

  > 比如**图一是一个强连通图，而图二不是** （因为没有一条路使得点4到达点1、2或3） 

  ![](../../pics/alg/alg_7_4.png)

-  **强连通分量**： **在一个非强连通图中极大的强连通子图就是该图的强连通分量**

  >  比如图三中子图{1,2,3,5}是一个强连通分量，子图{4}是一个强连通分量

  ![](../../pics/alg/alg_7_5.png)

#### 3. 详解

> **在任何深度优先搜索中，同一强连通分量内的所有顶点均在同一棵深度优先搜索树中**

- 从任意一个点开始深搜，**对图进行 DFS**
- **求图的反图**


- **根据第1步得到的排序，从最晚完成的一个点开始搜索并染色**
- **第三步每一次深搜完成就是一个强连通分量**

![](../../pics/alg/alg_7_6.png)

#### 4. 时间复杂度

​	$$T(n) = \theta(V + E)$$

## 2. 最小生成树(贪婪)

### 1. 概念

- **连通图：** 在**无向图**中，若任意两个顶点 $v_i$ 与 $v_j$ 都有路径相通，则称该无向图为连通图
- **强连通图：** 在**有向图**中，若任意两个顶点 $v_i$ 与 $v_j$ 都有路径相通，则称该有向图为强连通图
- **连通网：** 在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网
- **生成树：** 一个连通图的生成树是指一个连通子图，它**含有图中全部n个顶点**，但只有足以构成**一棵树的n-1条边**。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环
- **最小生成树：** 在连通网的所有生成树中，**所有边的代价和最小的生成树**，称为最小生成树

![](../../pics/alg/alg_7_7.png)

### 1. Kruskal算法（加边法）

#### 1. 伪代码

```c
MST-KRUSKAL(G,w)
	A = null
	for each vertex v 属于G.V
		MAKE-SET(v)
	sort the edges of G.E into nondecreasing order by weight w
	for each edges(u,v)属于G.E,taken in nondecreasing order by weight
		if FIND-SET(v) != FIND-SET(v)
			A = A and {(u,v)}
			UNION(u,v)
	return A
```

#### 2. 详解

初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里：

- 把图中的**所有边按代价从小到大排序**
- 把图中的n个顶点看成独立的n棵树组成的森林
- **按权值从小到大选择边**，所选的边连接的两个顶点 **$u_i , v_i$ 应属于两颗不同的树**，则成为最小生成树的一条边，并将这两颗树合并作为一颗树
- 重复(3),**直到所有顶点都在一颗树内或者有n-1条边为止**

![](../../pics/alg/alg_7_8.png)

####  3. 时间复杂度

​	$$T(n) = E * lgV$$

### 2. Prim算法（加点法）

#### 1. 伪代码

```c
MST-PRIM(G,w,r)
	for each u 属于 G.V
		v:key = 无穷
		v:pi = NIL
	r:key = 0
	Q = G.V
	while Q != null
		u = EXTRACT-MIN(Q)
		for each v属于G.Adj[u]
			if v 属于 Q and w(u,v) < v.key
				v.pi = u
				v.key = w(u,v)
```

#### 2. 详解

每次迭代选择代价最小的边对应的点，加入到最小生成树中：

- 图的所有顶点集合为 $V$ ；初始令集合 u={s} , v=V−u
- 在两个集合 $u,v$ 能够组成的边中，**选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把 $v_0$ 并入到集合u中** 
- 重复上述步骤，**直到最小生成树有n-1条边或者n个顶点为止**

![](../../pics/alg/alg_7_9.png)

#### 3. 时间复杂度

​	$$T(n) = E * lgV$$

## 3. 单源最短路径

- **给定源顶点 $s∈V$  到分别到其他顶点 $v∈V−\{ s \}$ 的最短路径的问题** 

### 1. Bellman-Ford 算法

#### 1. 伪代码

```c
BELLMAN-FORD(G, w, s)
   INITIALIZE-SINGLE-SOURCE(G, s)
   for i  1 to |V[G]| - 1
        do for each edge (u, v)  E[G]
             do RELAX(u, v, w)
   // 检查是否存在权值为负的环
   for each edge (u, v)  E[G]
        do if d[v] > d[u] + w(u, v)
             then return FALSE
   return TRUE
```

#### 2. 详解（动态规划）

- **初始化：** 将除源点外的所有顶点的最短距离估计值 dist[v] ← +∞, dist[s] ←0


- **迭代求解：** **反复对边集E中的每条边进行松弛操作**，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离（运行|v|-1次） 

- **检验负权回路： **判断边集E中的每一条边的两个端点是否收敛

  > - 如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true
  > - 从源点可达的顶点v的最短距离保存在 dist[v]中

  ![](../../pics/alg/alg_7_13.png)

#### 3. 时间复杂度

​	$$T(n)=O(E∗V)$$

### 2. Dijkstra 算法(权值非负)

#### 1. 伪代码

```c
DIJKSTRA(G,w,s)
	INITIALIZE-SINGLE-SORT(G,s)
	S = null
	Q = G.V
	while Q != null
		u = EXTRACT-MIN(Q)
		S = S + {u}
		for each vertex v 属于G.Adj[u]
			RELAX(u,v,w)
```

#### 2. 详解（贪婪算法）

> - **按路径长度递增的顺序，逐个产生各顶点的最短路径**
>
>
> - **顶点集 S 保存已经找到最短路径的顶点** 
> - 距离数组dist, **dist[i] 表示第i个顶点与源结点s的距离长度**

- $S$ 初始化时只包括源节点s
  dist[] 初始化：dist[i]= $arc[s][i]$ ,arc为图的邻接矩阵
  $V−S$ 表示未被找到最短的路径的顶点集合

- 把 dist 按递增的顺序，选择一个最短路径，从 $V−S$ 把对应顶点加入到 S 中，每次 S 中加入一个新顶点 u , 需要对 dist 更新，即 s 能否通过顶点 u 达到其他顶点更近

  即若 $dist[u] + arc[u][v] < dist[v]$ ,则更新 $dist[v]=dist[u]+arc[u][v]$ 

- 重复上述步骤，直到 S = V

![](../../pics/alg/alg_7_10.png)

![](../../pics/alg/alg_7_11.png)

![](../../pics/alg/alg_7_12.png)

#### 3. 时间复杂度

​	$$T(n)=O(E+VlogV)$$

## 4. 全源最短路径

### 1. Floyd-Warshall 算法

#### 1. 伪代码

```c
FLOYD-WARSHALL(W)
	n = W.rows
	D(0) = W
	for k = 1 to n
		let D(k) = d(k)_ij be a new nXn matrix
		for i = 1 to n
			for j = 1 to n
				d(k)_ij = min(d(k-1)_ij,d(k-1)_ik + d(k-1)_kj)
	return D(n)
```

#### 2. 详解(动态规划)

![](../../pics/alg/alg_7_14.png)

#### 3. 时间复杂度

​	$$T(n) = \theta(n^3)$$

### 2. Johnson 算法

#### 1. 伪代码

![](../../pics/alg/alg_4.png)

#### 2. 详解

**算法步骤简述：**

- 给定图 G = (V, E)，增加一个新的顶点 s，使 s 指向图 G 中的所有顶点都建立连接，设新的图为 G’
- 对于每个边 (u, v)，其**新的权值为 w(u, v) + (h[u] - h[v])** （u-->v）
- 移除新增的顶点 s，对每个顶点**运行Dijkstra 算法求得最短路径**
- **图 c~g 中，每个顶点包含两个值，分别为 新权值和老权值 的计算结果**，**用 / 分割**

![](../../pics/alg/alg_7_15.png)

![](../../pics/alg/alg_7_16.png)

#### 3. 时间复杂度

​	$$T(n)=O(V^2∗logV+V∗E)$$

## 5. 最大网络流

### 1. 概念

![](../../pics/alg/alg_7_17.png)

![](../../pics/alg/alg_7_18.png)

![](../../pics/alg/alg_7_19.png)

### 2. Ford-Fulkerson 算法

#### 1. 残存网络与增广路径

##### 1. 残存网络 

- **是指给定网络和一个流，其对应还可以容纳的流组成的网络** 

> 例如： 
>
> - 从 u 到 v 已经有了3个单位流量，那么从反方向上看，也就是从v到u就有了3个单位的残留网络，这时r（v，u）=3
> - 可以这样理解，**从u到v有3个单位流量，那么从v到u就有了将这3个单位流量的压回去的能力**

我们来具体看一个例子，如下图所示一个流网络



![](../../pics/alg/alg_7_20.png)

**对应残存网络：**

![](../../pics/alg/alg_7_21.png)

##### 2. 增广路径 

- 已知一个流网络G和流f，增广路径 p 是其残留网络 G-f 中从 s 到 t 的一条简单路径
- 形象的理解为**从 s 到 t 存在一条不违反边容量的路径**，向这条路径压入流量，可以增加整个网络的流值

**上面的残留网络中，存在这样一条增广路径：**

![](../../pics/alg/alg_7_22.png)

> 继续在新的流网络上用同样的方法寻找增广路径，直到找不到为止，这时我们就得到了一个最大的网络流

##### 3. 流网络的割

- 流网络G（V，E）的割（S，T）将V划分为 S 和 T=V-S 两部分，使得 s 属于S，t 属于T
- **割（S，T）的容量** 是指从集合S到集合T的所有边（有方向）的容量之和
- 如果 f 是一个流，则穿过割（S，T）的净流量被定义为f（S，T）

随便画一个割，如下图所示：

![](../../pics/alg/alg_7_23.png)

- **割的容量：** `c(u,w)+c(v,x)=26` 
- **穿过割的净流量：** `f(u,w)+f(v,x)-f(w,v)=12+11-4=19`

**流网络的流量守恒的原则：** 对网络的任意割，其净流量的都是相等的

##### 4. 定理

> **当残存网络中不存在一条从 s 到 t 的增广路径，那么该图已经达到最大流**

#### 2. 伪代码

```c
FORK-FULKERSON(G,s,t)
	for each edge(u,v) 属于 G.E
		(u,v).f = 0
	while there exists a path p form s to t in the residual network G_f
		c_f(p) = min{c_f(u,v):(u,v) is in p}
		for each edge(u,v) in p
			if (u,v) 属于 E
				(u,v).f = (u,v).f + c_f(p)
			else (v,u).f = (v,u).f - c_f(p)
```

#### 3. 详解

- 该图初始状态，绿色线条为正流量权重，灰色线条为反流量权重：

  ![](../../pics/alg/alg_7_24.png)

- 找到一条从s->t的路径：s->v1->v2->t，该路径的最大流量为2，则更新完流量以后的图如下图所示：

  ![](../../pics/alg/alg_7_25.png)

- 找到一条由s->t的路径：s->v1->t，该路径的流量限制为2,则更新完流量以后如下图所示：

  ![](../../pics/alg/alg_7_26.png)

- 找到另外一条由s->的路径：s->v2->v1->t，该路径的流量限制为2。则更新完流量以后如图所示：

  ![](../../pics/alg/alg_7_27.png)

- 找到另一条由s->t的路径：s->v2->t,该路径的流量限制为2,则更新完流量以后如下图所示：

  ![](../../pics/alg/alg_7_28.png)

- **找不到其它由s->t的路径，则增广结束，找到最大流值为8**

> **算法导论书 P425 图26-6 ==> 可以只看左边的残存网络**

#### 4. 时间复杂度

​	$$T(n)=O(E∗∣f∣)$$

### 2. Edmonds-Karp 算法

#### 1. 简介

> **使用 BFS 来改善 Ford-Fulkerson 算法的效率**

#### 2. 详解

步骤同上，只不过通过 BFS 来寻找增广路径

#### 3. 时间复杂度

​	$$T(n) = O(V * E^2)$$

### 3. 最大二分匹配

#### 1. 概念

- **二分图**：设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点 i 和 j 分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图
- **匹配**：如果子集 M 中的某条边与结点 v 相连，则称结点 v 由 M 所匹配
- **最大匹配**：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配
- **完美匹配**：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配

#### 2. 求解

> **二分图 G 中的一个最大匹配 M 的基数等于其对应的流网络 $G'$ 中某一最大流 f 的值** 

# 八、回溯法

## 1. 回溯法 -- 深度优先搜索

### 1. 简单概述

- 回溯法思路的简单描述：把问题的解空间转化成图或树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解

  > 基本思想类同于：
  >
  > - 图的深度优先搜索
  > - 二叉树的后序遍历

### 2. 详细描述

**回溯法按深度优先策略搜索问题的解空间树**：首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用**剪枝函数**判断该节点是否可行

- 如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯
- 否则，进入该子树，继续按深度优先策略搜索

回溯法的基本行为是搜索，搜索过程使用剪枝函数来避免无效的搜索，剪枝函数包括两类：

- 使用约束函数，剪去不满足约束条件的路径
- 使用限界函数，剪去不能得到最优解的路径

问题的关键在于如何定义问题的解空间，转化成树(即解空间树)，解空间树分为两种：**子集树和排列树** 

## 2. 回溯法 -- 递归和递推迭代

> 类比于图深度遍历的递归实现和非递归（递推）实现

### 1. 递归

> 思路简单，设计容易，但效率低

```c
void backTrack(int t){
    if (t > n) output(x); //叶子节点，输出结果，x 是可行解
    else {
        for i = 1 to k { //当前节点的所有子节点
            x[t] = value(i); //每个子节点的值赋给 x
            if (constrain(t) && bound(t))
                backTrack(t + 1); //递归下一层
        }
    }
}
```

### 2. 递推

> 算法设计相对复杂，但效率高

```c
//针对N叉树的迭代回溯方法  
void iterativeBacktrack ()  {  
    int t=1;  
    while (t>0) {  
        if(ExistSubNode(t)){ //当前节点的存在子节点  
            for i = 1 to k{ //遍历当前节点的所有子节点  
                x[t]=value(i);//每个子节点的值赋值给x  
                if (constraint(t)&&bound(t)){ //满足约束条件和限界条件   
                    //solution表示在节点t处得到了一个解  
                    if (solution(t)) output(x);//得到问题的一个可行解，输出  
                    else t++;//没有得到解，继续向下搜索  
                }  
            }  
        }  
        else{ //不存在子节点，返回上一层  
            t--;  
        }  
    }  
}  
```

## 3. 子集树和排列树

### 1. 子集树

> 问题： 从 n 个元素的集合 S 中找出满足某种性质的子集时，相应的解空间成为子集树
>
> - 0-1背包问题： 从所给重量、价值不同的物品中挑选几个物品放入背包，使得在满足背包不超重的情况下，背包内物品价值最大
>
>   > 它的解空间就是一个典型的子集树

```c
void backtrack (int t)  {  
  if (t>n) output(x);  
  else  
      for (int i=0;i<=1;i++) {  
        x[t]=i;  
        if (constraint(t)&&bound(t)) backtrack(t+1);  
      }  
}
```

### 2. 排列树

> 问题： 确定 n 个元素满足某种性质的排列时，相应的解空间就是排列树
>
> - 旅行售货员问题： 一个售货员把几个城市旅行一遍，要求走的路程最小
>
>   > 它的解就是几个城市的排列，解空间就是排列树

```c
void backtrack (int t)  {  
    if (t>n) output(x);  
    else {
        for (int i=t;i<=n;i++) {  
        	swap(x[t], x[i]);  
        	if (constraint(t)&&bound(t)) 
                backtrack(t+1);  
        	swap(x[t], x[i]);  
        }  
    }
}
```

## 4. 经典问题

### 1. 0-1 背包问题

- **问题：**给定 n 种物品和一背包。物品i的重量是wi，其价值为pi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?
- **分析：**问题是n个物品中选择部分物品，可知，问题的解空间是子集树。比如物品数目n=3时，其解空间树如下图，边为1代表选择该物品，边为0代表不选择该物品。使用x[i]表示物品i是否放入背包，x[i]=0表示不放，x[i]=1表示放入。回溯搜索过程，如果来到了叶子节点，表示一条搜索路径结束，如果该路径上存在更优的解，则保存下来。如果不是叶子节点，是中点的节点（如B），就遍历其子节点（D和E），如果子节点满足剪枝条件，就继续回溯搜索子节点

```c
#include <stdio.h>  
   
#define N 3         //物品的数量  
#define C 16        //背包的容量  
   
int w[N]={10,8,5};  //每个物品的重量  
int v[N]={5,4,1};   //每个物品的价值  
int x[N]={0,0,0};   //x[i]=1代表物品i放入背包，0代表不放入  
   
int CurWeight = 0;  //当前放入背包的物品总重量  
int CurValue = 0;   //当前放入背包的物品总价值  
   
int BestValue = 0;  //最优值；当前的最大价值，初始化为0  
int BestX[N];       //最优解；BestX[i]=1代表物品i放入背包，0代表不放入  
   
//t = 0 to N-1  
void backtrack(int t) {  
    if(t>N-1) { //叶子节点，输出结果
        //如果找到了一个更优的解  
        if(CurValue>BestValue){  
            //保存更优的值和解  
            BestValue = CurValue;  
            for(int i=0;i<N;++i) BestX[i] = x[i];  
        }  
    } else {  
        //遍历当前节点的子节点：0 不放入背包，1放入背包  
        for(int i=0;i<=1;++i) {  
            x[t]=i;  
            if(i==0) {  //不放入背包
                backtrack(t+1);  
            } else { //放入背包
                if((CurWeight+w[t])<=C) {  //约束条件：放的下
					CurWeight += w[t];  
                    CurValue += v[t];  
                    backtrack(t+1);  
                    CurWeight -= w[t];  
                    CurValue -= v[t];  
                }  
            }  
        }  
        //PS:上述代码为了更符合递归回溯的范式，并不够简洁  
    }  
}  
   
int main(int argc, char* argv[]) {  
    backtrack(0);  
    printf("最优值：%d\n",BestValue);  
    for(int i=0;i<N;i++) {  
       printf("最优解：%-3d",BestX[i]);  
    }  
    return 0;  
}
```

### 2. 旅行售货员问题



### 3. N 皇后问题

- **问题：**在 n×n 格的棋盘上放置彼此不受攻击的 n 个皇后

  > N皇后问题等价于在n×n格的棋盘上放置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上
  >
  > > 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子

- **分析**： 从 n×n 个格子中选择 n 个格子摆放皇后，可见解空间树为子集树

  - 使用 `Board[N][N]` 来表示棋盘，`Board[i][j]=0` 表示 `(i,j)` 位置为空，`Board[i][j]=1` 表示 `(i,j)` 位置摆放有一个皇后

  - 全局变量 way 表示总共的摆放方法数目

  - 使用 `Queen(t)` 来摆放第 t 个皇后，Queen(t) 函数符合子集树时的递归回溯范式： 

    - 当 `t>N` 时，说明所有皇后都已经摆放完成，这是可行的摆放方法，输出结果
    - 否则，遍历棋盘，找出皇后 `t` 所有可行的摆放位置，`Feasible(i,j)` 判断皇后 `t` 能否摆放在位置 `(i,j)` 处，如果可以摆放则继续递归摆放皇后 `t+1`，如果不能摆放，则判断下一个位置

    > `Feasible(row,col)` 函数： 
    >
    > - 首先判断位置 `(row,col)` 是否合法
    >
    > - 继而判断 `(row,col)` 处是否已有皇后： 
    >
    >   - 有，则冲突，返回 0
    >
    >   - 无，则继续判断行、列、斜方向是否冲突
    >
    >     斜方向分为左上角、左下角、右上角、右下角四个方向，每次从（row,col）向四个方向延伸一个格子，判断是否冲突
    >
    >     如果所有方向都没有冲突，则返回1，表示此位置可以摆放一个皇后

![](../../pics/alg/alg_28.png)

```c
#include <stdio.h>  
   
#define N 8  
   
int Board[N][N]; //棋盘 0表示空白 1表示有皇后  
int way; //摆放的方法数     
   
//判断能否在(x,y)的位置摆放一个皇后；0不可以，1可以  
int Feasible(int row,int col) {  
    if(row>N || row<0 || col >N || col<0) //位置不合法 
        return 0;  
    //该位置已经有皇后了，不能  
    if(Board[row][col] != 0) {   //在行列冲突判断中也包含了该判断，单独提出来为了提高效率  
        return 0;  
    }  
    //////////////////////////////////////////////////  
    //下面判断是否和已有的冲突  
    for(int i=0;i<N;++i) { //行和列是否冲突
        if(Board[row][i] != 0 || Board[i][col]!=0)  
            return 0;  
    }  
    for(int i=1;i<N;++i) { //斜线方向冲突  
		/* i表示从当前点(row,col)向四个斜方向扩展的长度 
		左上角 \  / 右上角   i=2 
        		\/           i=1 
        		/\           i=1 
		左下角 /  \ 右下角   i=2 
		*/  
        
        //左上角  
        if((row-i)>=0 && (col-i)>=0) { //位置合法
            if(Board[row-i][col-i] != 0)//此处已有皇后，冲突  
                return 0;  
        }  
        //左下角  
        if((row+i)<N && (col-i)>=0) {  
            if(Board[row+i][col-i] != 0)  
                return 0;  
        }  
        //右上角  
        if((row-i)>=0 && (col+i)<N) {  
            if(Board[row-i][col+i] != 0)  
                return 0;  
        }  
        //右下角  
        if((row+i)<N && (col+i)<N) {  
            if(Board[row+i][col+i] != 0)  
                return 0;  
        }  
    }  
    return 1; //不会发生冲突，返回1  
}  
   
   
//摆放第t个皇后 ；从1开始  
void Queen(int t)  {  
    if(t>N) { //摆放完成，输出结果  
        way++;  
        /*如果N较大，输出结果会很慢；N较小时，可以用下面代码输出结果 
        for(int i=0;i<N;++i){ 
            for(int j=0;j<N;++j) 
                printf("%-3d",Board[i][j]); 
            printf("\n"); 
        } 
        printf("\n------------------------\n\n"); 
        */  
    } else {  
        for(int i=0;i<N;++i) {  
            for(int j=0;j<N;++j) {  
                //（i,j）位置可以摆放皇后，不冲突  
                if(Feasible(i,j)) {  
                    Board[i][j] = 1;  //摆放皇后t  
                    Queen(t+1);       //递归摆放皇后t+1  
                    Board[i][j] = 0;  //恢复  
                }  
            }  
        }  
    }  
}  
   
//返回num的阶乘,num!  
int factorial(int num) {  
    if(num==0 || num==1)  
        return 1;  
    return num*factorial(num-1);  
}  
   
int main(int argc, char* argv[])  {  
    //初始化  
    for(int i=0;i<N;++i) {  
        for(int j=0;j<N;++j) {  
            Board[i][j]=0;  
        }  
    }  
    way = 0;  
    Queen(1);  //从第1个皇后开始摆放  
    //如果每个皇后都不同  
    printf("考虑每个皇后都不同，摆放方法：%d\n",way);//N=8时, way=3709440 种  
    //如果每个皇后都一样，那么需要除以 N！出去重复的答案（因为相同，则每个皇后可任意调换位置）  
    printf("考虑每个皇后都不同，摆放方法：%d\n",way/factorial(N));//N=8时, way=3709440/8!=92种 
    return 0;  
}  
```

> 该问题还有更优的解法。充分利用问题隐藏的约束条件：每个皇后必然在不同的行(列)，每个行(列)必然也只有一个皇后。这样我们就可以把N个皇后放到N个行中，使用Pos[i]表示皇后i在i行中的位置（也就是列号）（i = 0 to N-1）。这样代码会大大的简洁，因为节点的子节点数目会减少，判断冲突也更简单

### 4. 迷宫问题

- **问题**： 给定一个迷宫，找到从入口到出口的所有可行路径，并给出其中最短的路径

- **分析**： 用二维数组来表示迷宫，则走迷宫问题用回溯法解决的的思想类似于图的深度遍历，从入口开始，选择下一个可以走的位置，如果位置可走，则继续往前，如果位置不可走，则返回上一个位置，重新选择另一个位置作为下一步位置

  - `N` 表示迷宫大小，`Maze[N][N]` 表示迷宫，值为 0 表示通道(可走)，值为1表示不可走(墙或已走过)

  - `Point` 结构体用来记录路径中每一步的坐标 `(x,y)`

  - `(ENTER_X,ENTER_Y)` 是迷宫入口的坐标
  - `(EXIT_X, EXIT _Y)` 是迷宫出口的坐标

  - `Path` 容器用来存放一条从入口到出口的通路路径

  - `BestPath` 用来存放所有路径中最短的那条路径

`Maze()` 函数用来递归走迷宫，具体步骤为：

1. 首先将当前点加入路径，并设置为已走
2.  判断当前点是否为出口，是则输出路径，保存结果；跳转到4
3. 依次判断当前点的上、下、左、右四个点是否可走，如果可走则递归走该点
4. 当前点推出路径，设置为可走

```c
#include <iostream>  
#include <vector>  
   
using namespace std;  
   
typedef struct {  
    int x;  
    int y;  
}Point;  
   
#define N 10         //迷宫的大小  
#define ENTER_X 0    //入口的位置（0，0）  
#define ENTER_Y 0  
#define EXIT_X N-1   //出口的位置(N-1,N-1)  
#define EXIT_Y N-1   
   
int Maze[N][N]; //定义一个迷宫，0表示通道，1表示不可走（墙或已走）  
int paths; //路径条数  
vector<Point> Path; //保存一条可通的路径  
vector<Point> BestPath; //保存最短的路径  
bool First = true; //标志，找到第一条路径  
   
//初始化迷宫  
void InitMaze()  { 
	//定义一个迷宫，0表示通道，1表示墙(或不可走)
    int mz[10][10]={  
        {0,0,1,1,1,1,1,1,1,1}, //0  
        {1,0,0,1,1,0,0,1,0,1}, //1  
        {1,0,0,1,0,0,0,1,0,1}, //2  
        {1,0,0,0,0,1,1,0,0,1}, //3  
        {1,0,1,1,1,0,0,0,0,1}, //4  
        {1,0,0,0,1,0,0,0,0,1}, //5  
        {1,0,1,0,0,0,1,0,0,1}, //6  
        {1,0,1,1,1,0,1,1,0,1}, //7  
        {1,1,0,0,0,0,0,0,0,0}, //8  
        {1,1,1,1,1,1,1,1,1,0}  //9  
        //   0 1 2 3 4 5 6 7 8 9  
    };   
    //复制到迷宫  
    memcpy(Maze,mz,sizeof(mz));  
    paths = 0;  
}  
   
//从(x,y)位置开始走；初始为(0,0)  
void MazeTrack(int x,int y)  {  
    Point p={x,y}; //当前点加入到路径
    Path.push_back(p);  
    Maze[x][y] = 1;         //设置为已走，不可走  
    if(x == EXIT_X && y== EXIT_Y) { //如果该位置是出口，输出结果
        cout<<"找到一条道路"<<endl;  
        paths++;  
        //输出路径  
        vector<Point>::iterator it;  
        for(it=Path.begin();it!=Path.end();++it) {  
            cout<<"("<<it->x<<","<<it->y<<") ";  
        }  
        cout<<endl;  
        //判断是否更优  
        if(First) { //如果是找到的第一条路径，直接复制到最优路径
            for(it=Path.begin();it!=Path.end();++it) {  
                BestPath.push_back(*it);  
            }  
            First = false;  
        }  
        else { //不是第一条，则判断是否更短
            //更短，复制到最优路径  
            if(Path.size()<BestPath.size()) {  
                BestPath.clear();  
                for(it=Path.begin();it!=Path.end();++it) {  
                    BestPath.push_back(*it);  
                }  
            }  
        }  
    }  
    //判断(x,y)位置的上、下、左、右是否可走  
    if((x-1)>=0 && Maze[x-1][y]==0) { //上(x-1,y)；存在且可走
        MazeTrack(x-1,y);  
    }  
    if((x+1)<N && Maze[x+1][y]==0) { //下(x+1,y)；存在且可走  
        MazeTrack(x+1,y);  
    }  
    if((y-1)>=0 && Maze[x][y-1]==0) { //左(x,y-1)；存在且可走  
        MazeTrack(x,y-1);  
    }  
    if((y+1)<N && Maze[x][y+1]==0) { //右(x,y+1)；存在且可走  
        MazeTrack(x,y+1);  
    }  
    //返回上一步  
    Path.pop_back();  
    Maze[x][y] = 0;         //设置为未走  
}  
   
int main(int argc, char* argv[])  {  
    //初始化迷宫  
    InitMaze();  
          
	/*  //显示迷宫 
    for(int i=0;i<N;++i){ 
        for(int j=0;j<N;++j) 
            cout<<Maze[i][j]<<"  "; 
        cout<<endl; 
    }*/  
   
    //回溯法走迷宫  
    MazeTrack(ENTER_X,ENTER_Y);  
   
    //显示最优的路径  
    cout<<"可行路径总条数为"<<paths<<"；最优路径为"<<endl;  
    vector<Point>::iterator it;  
    for(it=BestPath.begin();it!=BestPath.end();++it) {  
        cout<<"("<<it->x<<","<<it->y<<") ";  
    }  
    cout<<endl;  
    return 0;  
}  
```

# 九、分支界限法(剪枝法)

## 1. 定义

- 分支限界算法： 按照**广度优先**的方式对解空间树(状态空间树)进行搜索，从而求得最优解的算法。
  - 搜索过程中，采用**限界函数**估算所有子节点的目标函数的可能取值
  - 从而选择使目标函数取极值(极大值或极小值)的节点作为扩展结点（如果限界值没有超过目前的最优解，则剪枝）进行下一步搜索(重复 BFS -> 计算所有子节点限界 -> 选择最优子节点作为扩展结点的过程)
  - 从而不断调整搜索的方向，尽快找到问题的最优解

- 特点： 分支限界的思想类似于：图的广度优先搜索，树的层序遍历
- 对比： 
  - 回溯算法求出满足约束的所有可行解
  - 分支限界求出满足约束的解中使得目标函数达到极值的最优解

## 2. 与回溯算法的不同点

- **在子结点的扩展方式上不同**：

  - 回溯算法采用**轮流遍历子节点的方式**扩展结点

  - 分支限界采用**活结点的方式**，一次性对所有的可行子节点进行扩展

    > 估算子节点目标函数的可能值： 
    >
    > - 如果该子节点的目标函数值差于当前最优解，则丢弃
    > - 否则将其加入活叶子表，依次从表中选取使目标函数取极值的节点作为当前的扩展结点
    >
    > 重复这一过程，直到找到最优解

- **在解空间树的搜索方式上不同**：

  - 回溯算法采用**深度优先搜索**的方式去搜索解空间树

    > 搜索过程中，对所有的子节点轮流进行深度优先搜索： 
    >
    > - 一旦发现有不满足约束的子节点，则对该子节点为根的子树进行剪枝
    > - 否则就从该子节点深度优先搜索，直到搜索到一个满足约束条件的叶子节点，即求得一个可行解

  - 分支限界采用**广度优先搜索**的方式去搜索解空间树

    > 搜索过程中，先生成所有的子节点(分支)，然后对所有分支计算一个函数值(限界)：
    >
    > - 并根据这些函数值(计算出的上界或下界)，从中选择一个使目标函数最优(限界最优)的子节点作为扩展结点
    > - 使得搜索朝着最优解的方向快速推进，从而很快求得一个最优解

## 3. 算法的一般步骤

1. 将问题的解空间转化为图或树的结构表示，维护一张活叶子表(可以是优先队列)

2. 初始将根节点计算一个限界后加入活叶子表

3. 当活叶子表不为空时，**从活叶子表中取出一个限界最优的结点作为扩展结点，并将该节点去除出表**

   > 当活结点表为空时，算法结束

4. 判断当前的扩展结点是否可以满足所有约束，并且得到一个可行解(该扩展结点是叶子节点)

   > - 如果是，判断优于当前最优解后，记录并更新最优解，随后将当前最优解与所有活叶子节点的限界做比较，**对于限界差于最优解的活叶子结点，去除出活叶子表**，并返回 3
   > - 如果不是，则进入 5

5. 计算扩展结点的所有子节点是否满足约束条件

   > 对于不满足约束条件的子节点，将以该节点为根的子树剪枝(丢弃)

6. 根据限界函数，计算该节点满足约束的所有子节点的限界

   > - 对于限界差于当前最优解的子节点，将以该子节点为根的子树丢弃
   > - 对于限界优于当前最优解的子节点，将这些潜力节点作为活叶子结点添加到活叶子表，并返回 3

## 4. 算法应用的难点

- 解空间的构造，即状态空间树的构造方法（节点的生成顺序）

- 剪枝函数的确定，即约束规则的确定 

- 限界函数的确定，边界的评估方法

# 十、朴素贝叶斯

推荐阅读： [朴素贝叶斯算法原理小结](https://www.cnblogs.com/pinard/p/6069267.html) 

## 1. 统计学知识

> 贝叶斯学派的思想： ==先验概率 + 数据 = 后验概率== 

- 先看**条件独立公式**，如果 X 和 Y 相互独立，则有： $P(X,Y)=P(X)P(Y)$ 

- 接着看**条件概率公式**：

  > $P(Y|X)=P(X,Y)/P(X)$ 与 $P(X|Y)=P(X,Y)/P(Y)$
  >
  > 或
  >
  > $P(Y|X)=P(X|Y)P(Y)/P(X)$ 

- 接着看**全概率公式**： $P(X)=∑_kP(X|Y=Y_k)P(Y_k)其中∑_kP(Y_k)=1$ 

从上面的公式得出贝叶斯公式：

​					$$P(Y_k|X)=\frac{P(X|Y_k)P(Y_k)}{∑_kP(X|Y=Y_k)P(Y_k)}$$ 

##  2. 朴素贝叶斯的模型

　　　　

## 3. 朴素贝叶斯的推断过程



## 4. 朴素贝叶斯的参数估计



## 5.  朴素贝叶斯算法过程



## 6.  朴素贝叶斯算法小结





# 十一、互联网公司常用算法

推荐阅读： **[面试必须掌握的十个海量数据问题及解决方案](https://blog.csdn.net/hitxueliang/article/details/52153476)** 

## 1. TopN 算法

推荐阅读： 

- **[面试必须掌握的十个海量数据问题及解决方案](https://blog.csdn.net/hitxueliang/article/details/52153476)** 
- [深度解析某头条的一道TopN面试题](https://blog.csdn.net/bntX2jSQfEHy7/article/details/80276225) 

### 1. TopN问题描述

问题一：找出海量数据中出现次数最多的N个数据

问题二：找出两个超大文件中的相同字符串

问题三：找出超多整数中没有重复出现的整数，或多少以内没出现的整数

### 2. 解决方案

通用方案：分而治之的思想，先拆分成很多小文件，每个文件分别统计和排序，然后归并排序

问题一：除分而治之方案外，如果**无内存限制，则可用字典树**

问题二：除分而治之方案外，如果**容许有错，可用布隆过滤器**

问题三：可用位集或BitMap，将这组数据映射到BitSet，然后遍历BitSet，对应位为0的数表示没有出现过的数据

## 2. 数据结构

### 1. 字典树(Trie)

推荐阅读： **[字典树(前缀树)](https://blog.csdn.net/weixin_39778570/article/details/81990417)** 

- 字典树： 哈希树的变种，**有序**，**可用排序和保存大量的字符串**，常被搜索引擎系统用于文本词频统计

- 特点： 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高

  > 在查询时最大限度的减少无谓的字符串比较
  >
  > - 当字典树预处理好后，查询字符串的效率异常高效，故而常用于搜索引擎

- 缺点： 比较耗内存

![](../../pics/alg/alg_10.png)

> 这棵 Trie 树包含的字符串集合是`{in, inn, int, tea, ten, to}`
>
> 这些字符可以是任意一个字符集中的字符，比如： 
>
> - 对于都是小写字母的字符串，字符集就是’a’-‘z’
> - 对于都是数字的字符串，字符集就是’0’-‘9’
> - 对于二进制字符串，字符集就是0和1
>
> > 节点编号是为了描述方便加上去的

---

**实现思路**： Trie 树的创建从根节点开始，通过依次将 W1, W2, W3, … WN 插入实现，即关键是插入操作

支持的操作： 

- `Trie.insert(W)`：插入操作，就是将一个字符串 W 加入到集合中

  > 假设我们要插入字符串”in”： 
  >
  > - 开始从根节点开始，即 0 号节点(用 `P=0` 表示)，先查看是否标有 `i` 的节点，若没有则创建
  >
  >   ![](../../pics/alg/alg_11.png)
  >
  > - 然后再插入 `n`，同上，先查询是否存在 `n`，若没有则创建
  >
  >   > 因为 `n` 是 `in` 的最后一个字符，所以将 `P=2` 这个节点标记为终节点 
  >
  >   ![](../../pics/alg/alg_12.png)
  >
  > - 接着再插入字符串 `inn`，过程同上，因为 `i` 和 `n` 都存在所以只用创建 `n`(第二个 n)
  >
  >   ![](../../pics/alg/alg_13.png)
  >
  > - 将后面的字符串int tea ten to都插入之后，就得到了我们一开始给出的Trie：
  >
  >   ![](../../pics/alg/alg_10.png)

- `Trie.search(S)`：查询操作，就是查询一个字符串 S 是不是在集合中

  > 查找操作： 从根节点开始，沿着 `S[1] -> S[2] -> S[3] -> ... -> S[S.len]` 移动：
  >
  > - 如果最后成功到达一个终结点，则说明 `S` 存在 Trie 树中
  > - 如果最后无路可走或没有到达终结点，则说明 `S` 不在 Trie 树中

### 2. 布隆过滤器(Bloom Filter)

推荐阅读： **[布隆过滤器(Bloom Filter)详解](https://www.cnblogs.com/liyulong1982/p/6013002.html)** 

- **简介**： bloom 算法类似 hash set，用来判断某个元素(key)是否在某个集合中，但该算法无需存储 key 的值，对于每个key，只需要 k 个比特位，每个存储一个标志，用来判断 key 是否在集合中
  
  > 当一个元素被加入集合时，通过 `K` 个 `Hash 函数` 将这个元素映射成一个`位阵列（Bit array）中的 K 个点`，把它们置为 `1`。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了
  
- **算法流程**： 
  
  - 首先需要 k 个 hash 函数，每个函数把 key 散列成为 1 个整数

  - 初始化时，需要一个长度为 n 比特的数组，每个比特位初始化为 0
  
  - 某个 key 加入集合时，用 k 个 hash 函数计算出 k 个散列值，并把数组中对应的比特位置为 1
  
  - 判断某个 key 是否在集合时，用 k 个 hash 函数计算出 k 个散列值，并查询数组中对应的比特位，如果所有的比特位都是 1，认为在集合中
  
- 优点： **空间效率和查询时间**都远远超过一般的算法

  > - 存储空间和插入/查询时间都是常数`O(k)`
  > - 散列函数之间没有关系，方便硬件并行实现
  > - **不需要存储 key，节省空间**

- 缺点： 
  - 判断 key 在集合中时，有一定的概率 key 其实不在集合中
  - 删除困难或无法删除

**典型应用场景**：某些存储系统中，存在空查询缺陷：当查询不存在的 key 时，需要访问慢设备，导致效率低下

> 比如： 
>
> - 一个前端页面的缓存系统，可能这样设计：先查询某个页面在本地是否存在，如果存在就直接返回，如果不存在，就从后端获取
> - 但是当频繁从缓存系统查询一个页面时，缓存系统将会频繁请求后端，把压力导入后端

![](../../pics/alg/alg_14.png)

### 3. Counting Bloom Filter

- **实现**： 将标准 Bloom Filter 位数组的每一位扩展为一个小的计数器(Counter)，在插入元素时给对应的 k 个Counter 的值分别加1，删除元素时给对应的 k 个 Counter 的值分别减 1

  > Counting Bloom Filter 通过多占用几倍的存储空间的代价，给 Bloom Filter 增加了删除操作

- 问题： 到底要**多占用几倍空间**

  > 推导出 4 位(即 $2^4 = 16$) 比较合适
  >
  > 具体详细计算，请参看： **[Bloom Filter 算法与 Counting Bloom Filter 算法](https://my.oschina.net/kiwivip/blog/133498)**
  >
  > ![](../../pics/alg/alg_15.png)

### 4. BitMap

推荐阅读： [BitMap算法详解](https://www.cnblogs.com/senlinyang/p/7885685.html) 

- BitMap： 用一个 `bit` 位来标记某个元素所对应的 value，而 key 即是该元素

  > 由于 BitMap 使用了 bit 位来存储数据，因此可以大大节省存储空间

- **适用情况**： 适用于大规模数据，但数据状态不是很多的情况

  > 通常用来判断某个数据是否存在

- **基本思想**： 

  > 假设要对 `0-7` 内的 5 个元素(4,7,2,5,3)进行排序，使用 BitMap 算法达到排序目的
  >
  > 要表示 8 个数，我们需要 8 个 byte：
  >
  > - 首先我们开辟一个字节(8byte)的空间，将这些空间的所有的 byte 位都设置为 0
  >
  > - 然后遍历这 5 个元素，第一个元素是4，因为下边从0开始，因此我们把第五个字节的值设置为1
  >
  > - 然后再处理剩下的四个元素，最终8个字节的状态如下图
  >
  > 　　![img](https://images2017.cnblogs.com/blog/1271073/201711/1271073-20171123161525821-718918482.png)
  >
  > - 现在我们遍历一次 bytes 区域，把值为 1 的byte的位置输出(2,3,4,5,7)，这样便达到了排序的目的
  >
  > BitMap 算法的思想比较简单，关键问题是如何确定 10 进制的数到 2 进制的==映射图== 

- **运用范围**： 可以运用在快速查找、去重、排序、压缩数据等

------

**大数据处理场景**： 

1. 给定 40 亿个不重复的 int 整数(未排序)，然后再给一个数，如何快速判断这个数是否在这 40 亿个数中

   > 解法：遍历40亿数字，映射到 BitMap 中，然后对于给出的数，直接判断指定的位上存在不存在即可

2. 使用位图法判断整形数组是否存在重复

   > 解法：遍历一遍，存在之后设置成1，每次放之前先判断是否存在，如果存在，就代表该元素重复

3. 使用位图法进行元素不重复的整形数组排序

   > 解法：遍历一遍，设置状态 1，然后再次遍历，对状态等于 1 的进行输出，参考计数排序的原理

4. 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

   > - 解法1：采用2-Bitmap(每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义)
   > - 解法2：采用两个BitMap，即第一个Bitmap存储的是整数是否出现，接着，在之后的遍历先判断第一个BitMap里面是否出现过，如果出现就设置第二个BitMap对应的位置也为1，最后遍历BitMap，仅仅在一个BitMap中出现过的元素，就是不重复的整数
   > - 解法3：分治+Hash取模，拆分成多个小文件，然后一个个文件读取，直到内存装的下，然后采用Hash+Count的方式判断即可

### 5. 位集(BitSet)

推荐阅读： 

- [Java中BitSet的使用及详解](https://blog.csdn.net/jiangnan2014/article/details/53735429)

- **[一道面试题与Java位操作 和 BitSet 库的使用](https://www.cnblogs.com/yellowb/p/3647442.html)**

---

> **Java BitSet 是 BitMap 的实现** 

- BitSet 是位操作的对象，值只有 0 或 1，即 false 和 true，内部维护了一个 long 数组，初始只有一个 long

  > 因此 BitSet 最小的 size 是 64，当随着存储的元素越来越多，BitSet 内部会动态扩充，最终内部是由 N 个long来存储，这些针对操作都是透明的

- 用 1 位来表示一个数据是否出现过，0为没有出现过，1表示出现过

  >  一个1G的空间，有 $8*1024*1024*1024=8.58*10^9$ bit，也就是可以表示85亿个不同的数

- 内存增长方式： 分配内存时以字节为单位，因此以 `64,128,192,...` 方式递增

  > 注意： 标准库在实现 bitset 时**以字为基本单位**分配内存(不是字节)，即分配的内存必定是 `4byte` 整数倍

使用场景： 

- 统计 40 亿个数据中没有出现的数据

  > **等同计数排序** 

- 将 40 亿个不同数据进行排序等

  > **等同计数排序**
  >
  > ```java
  > public class BitSort {
  >     public static void main(String[]args){
  >         final int size=10;
  >         int A[]={23,44,1,2,34,56,11,7,9,25};
  >         bitSort(A);
  >         for(int i=0;i<A.length;i++){
  >             System.out.print(A[i]+" ");
  >         }
  >     }
  >     public static void bitSort(int[]A){
  >         int size=A.length;
  >         //这个数的大小必须大于数组 A 中元素的最大值
  >         final int number_range = 60;
  >         BitSet bits = new BitSet(number_range);
  >         for(int i = 0;i < size;i++){
  >             bits.set(A[i]);
  >         }
  >         for(int i=0,j=0;i<number_range;i++){
  >             if(bits.get(i)){
  >                 A[j++]=i;
  >             }
  >         }
  >         System.out.println("bits的内存："+bits.size());
  >     }
  > }
  > ```

- 在内存对 40 亿个数据进行压缩存储

- 有1千万个范围在1到1亿之间的随机数，现在将1到1亿之间没有在随机数中的数求出来

- 快速找出 0-255 中哪个数字可用

---

BitSet 与 Byte 数组互转：

```java
import java.util.Arrays;
import java.util.BitSet;

public class BitSetConvert {
	public static byte[] bitSet2ByteArray(BitSet bitSet) {
		byte[] bytes = new byte[bitSet.size() / 8];
		for (int i = 0; i < bitSet.size(); i++) {
			int index = i / 8;
			int offset = 7 - i % 8;
			bytes[index] |= (bitSet.get(i) ? 1 : 0) << offset;
		}
		return bytes;
	}

	public static BitSet byteArray2BitSet(byte[] bytes) {
		BitSet bitSet = new BitSet(bytes.length * 8);
		int index = 0;
		for (int i = 0; i < bytes.length; i++) {
			for (int j = 7; j >= 0; j--) {
				bitSet.set(index++, (bytes[i] & (1 << j)) >> j == 1 ? true
						: false);
			}
		}
		return bitSet;
	}
	
	public static void main(String[] args) {
		BitSet bitSet = new BitSet();
		bitSet.set(0, true);
		bitSet.set(10, true);
		//将BitSet对象转成byte数组
		byte[] bytes = bitSet2ByteArray(bitSet);
		System.out.println(Arrays.toString(bytes));
		
		//在将byte数组转回来
		bitSet = byteArray2BitSet(bytes);
		System.out.println(bitSet.get(0));
		System.out.println(bitSet.get(10));
	}
}
```

## 3. KMP 字符串匹配算法

推荐阅读： 

- ==移动位数 = 已匹配的字符数 - 对应的部分匹配值== 

  > **部分匹配值**： 字符串头部和尾部有重复的字符串位数
  >
  > 例如： "ABCDAB"之中有两个"AB"，那么它的"部分匹配值"就是2（"AB"的长度）

![](../../pics/alg/alg_19.png)

![](../../pics/alg/alg_20.png)

![](../../pics/alg/alg_21.png)

![](../../pics/alg/alg_22.png)

![](../../pics/alg/alg_23.png)

![](../../pics/alg/alg_24.png)

![](../../pics/alg/alg_25.png)

![](../../pics/alg/alg_26.png)

![](../../pics/alg/alg_27.png)

## 4. 推荐算法

推荐阅读： [推荐算法文章](https://www.infoq.cn/profile/1277154?menu=publish#menu-trace) 

> 推荐系统算法通常是某类推荐模型的实现，负责获取数据，以及预测给定的用户组会对哪些选项感兴趣

推荐算法通常被分为四大类：

- 协同过滤推荐算法
- 基于内容的推荐算法
- 混合推荐算法
- 流行度推荐算法

### 1. 协同过滤推荐算法

- 简介：通过在用户的一系列行为中寻找特定模式来产生用户特殊推荐
- 输入：仅仅依赖于惯用数据（例如评价、购买、下载等用户偏好行为）
- 类型：
  - 基于邻域的协同过滤（基于用户和基于项）
  - 基于模型的协同过滤（矩阵因子分解、受限玻尔兹曼机、贝叶斯网络等等）
- 优点：
  - 需要最小域
  - 不需要用户和项
  - 大部分场景中能够产生足够好的结果
- 缺点：
  - 冷启动问题
  - 需要标准化产品
  - 需要很高的用户和项的比例（1：10）
  - 流行度偏见（有长尾的时候表现不够好）
  - 难于提供解释

### 2. 基于内容的推荐算法

- 简介：向用户推荐和其过去喜欢项的内容（例如元数据、描述、话题等等）相似的项
- 输入：仅仅依赖于项和用户的内容 / 描述（除了惯用数据）
- 类型：
  - 信息检索（例如 tf-idf 和 Okapi BM25）
  - 机器学习（例如朴素贝叶斯、支持向量机、决策树等等）
- 优点：
  - 没有冷启动问题
  - 不需要惯用数据
  - 没有流行度偏见，可以推荐有罕见特性的项
  - 可以使用用户内容特性来提供解释
- 缺点：
  - 项内容必须是机器可读的和有意义的
  - 容易归档用户
  - 很难有意外，缺少多样性
  - 很难联合多个项的特性

### 3. 混合推荐算法

- 简介：综合利用协同过滤推荐算法和基于内容的推荐算法各自的优点同时抵消各自的缺点
- 输入：同时使用用户和项的内容特性与惯用数据，同时从两种输入类型中获益
- 类型：
  - 加权
  - 交换
  - 混合
  - 特性组合
  - 案列
  - 特征增强
  - 元层次
- 优点：
  - 由于单独使用协同过滤推荐算法和基于内容的推荐算法
  - 没有冷启动问题
  - 没有流行度偏见，可推荐有罕见特性的项
  - 可产生意外，实现多样性
- 缺点：
  - 需要通过大量的工作才能得到正确的平衡

### 4. 流行度推荐算法

- 简介：这是一种推荐流行项的方法 (例如最多下载、最多看过、最大影响的项)
- 输入：使用惯用数据和项的内容（例如类目）
- 优点：
  - 相对容易实现
  - 良好的基准算法
  - 有助于解决新用户冷启动问题
- 缺点：
  - 需要标准化产品
  - 经常需要一些项的类型进行分类
  - 不会推荐新项（很少有机会被观测到）
  - 推荐列表不会改变太大

### 5. 高级非传统推荐算法

- 类型：
  - 深度学习
  - 学习等级
  - Multi-armed bandits（探索 / 开发）
  - 上下文感知推荐
  - 张量分解
  - 分解机
  - 社会推荐
- 优点：
  - 利于勉强维持最终性能百分点
  - 你可以说你正在使用渐进的方式
- 缺点：
  - 难于理解
  - 缺乏推荐工具支持
  - 没有为你的首个推荐系统提供推荐的方式