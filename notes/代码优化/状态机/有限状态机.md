# 一、枚举实现

## 1、方式一：简单枚举实现

### (1) 枚举类

定义包含方法的枚举类：

```java
public enum LeaveRequestState {
	Submitted {
		@Override
		public String responsiblePerson() {
		     return "Employee";
		}
	},
	Escalated {
		@Override
		public String responsiblePerson() {
		      return "Team Leader";
		}
	},
	Approved {
		@Override
		public String responsiblePerson() {
		      return "Department Manager";
		}
	};

    public abstract String responsiblePerson();
}
```

- 通过定义 responsiblePerson 来获取处理每个状态的负责人，如：Escalated 状态由 Team Leader 处理：

    ```java
    LeaveRequestState state = LeaveRequestState.Escalated;
    assertEquals("Team Leader", state.responsiblePerson());
    ```

- 同理可以检查 Approved 状态负责人：

    ```java
    LeaveRequestState state = LeaveRequestState.Approved;
    assertEquals("Department Manager", state.responsiblePerson());
    ```

### (2) 枚举实现状态机

通过枚举实现状态机时，不显式去设置状态，只需要提供状态转移的逻辑：

```java
public enum LeaveRequestState {
	Submitted {
		@Override
		public LeaveRequestState nextState() {
			return Escalated;
		}
        
        @Override
		public LeaveRequestState prevState() {
			return this;
		}
	
		@Override
		public String responsiblePerson() {
			return "Employee";
		}
	},
	Escalated {
		@Override
		public LeaveRequestState nextState() {
			return Approved;
		}
        
        @Override
		public LeaveRequestState prevState() {
			return Submitted;
		}
		
		@Override
		public String responsiblePerson() {
			return "Team Leader";
		}
	},
	Approved {
		@Override
		public LeaveRequestState nextState() {
			return this;
		}
        
        @Override
		public LeaveRequestState prevState() {
			return Escalated;
		}
		
		@Override
		public String responsiblePerson() {
			return "Department Manager";
		}
	};

	public abstract LeaveRequestState nextState();
    public abstract LeaveRequestState prevState();
	public abstract String responsiblePerson();
}
```

上面状态机的转换通过枚举方法 `nextState` 实现：

```java
LeaveRequestState state = LeaveRequestState.Submitted;

state = state.nextState();
assertEquals(LeaveRequestState.Escalated, state);

state = state.nextState();
assertEquals(LeaveRequestState.Approved, state);

state = state.nextState();
assertEquals(LeaveRequestState.Approved, state);
```

## 2、方式二：函数式接口实现

### (1) 完整定义

- **核心接口**：

    ```java
    //状态转换的转换器
    @FunctionalInterface
    public interface Transition<O, E, S extends Enum<S>> {
        /**
         * Transition hook.
         * @param operand: the entity attached to the FSM, whose internal state may change.
         * @param event: causal event
         * @return the postState: Post state must be one of the
         *             valid post states registered in StateMachine.
         */
        S transition(O operand, E event);
    }
    ```

- **状态机接口**：

    ```java
    /**
     * FSM 状态机接口
     * 
     * @param <S> 状态枚举类型
     * @param <T> 事件类型
     * @param <E> 事件
     */
    public interface StateMachine<S extends Enum<S>, T extends Enum<T>, E> {
        S getCurrentState(); //获取状态机的当前状态
    
        S doTransition(T eventType, E event); //做一次状态转换
    }
    ```

- **核心实现**：

    ```java
    /**
     * FSM 工厂
     *
     * @param <O> O operand 操作数类型
     * @param <S> S 状态机状态枚举类型
     * @param <T> T 事件类型
     * @param <E> E 事件
     * @author
     */
    public final class StateMachineFactory<O, S extends Enum<S>, T extends Enum<T>, E> {
        /**
         * 通过当前状态和事件类型获取用户注册的四元组
         * State(S) + Event(E, EventType(T)) + Operator(O)  -> State(S)'
         */
        private final Map<S, Map<T, Transition<O, E, S>>> transitionMachineTable = new HashMap<>();
    
        public void addTransition(S preState, S postState, T eventType, Transition<O, E, S> hook) {
            Map<T, Transition<O, E, S>> transitionMap 
                	= transitionMachineTable.computeIfAbsent(preState, k -> new HashMap<>(8));
            transitionMap.put(eventType, (o, e) -> {
                S r = hook.transition(o, e);
                if (Objects.equals(r, postState)) {
                    return postState;
                }
                throw new RuntimeException("Invalid event: " + e + " at " + preState);
            });
        }
    
        public void addTransition(S preState, Set<S> postStates, T eventType, Transition<O, E, S> hook) {
            Map<T, Transition<O, E, S>> transitionMap 
                	= transitionMachineTable.computeIfAbsent(preState, k -> new HashMap<>(8));
            transitionMap.put(eventType, (o, e) -> {
                S r = hook.transition(o, e);
                if (postStates.contains(r)) {
                    return r;
                }
                throw new RuntimeException("Invalid event: " + e + " at " + preState);
            });
        }
    
        public StateMachine<S, T, E> make(O operand, S initialState) {
            return new InternalStateMachine(operand, initialState);
        }
    
        //真正的状态机，一个状态机维护一个对象 operand 和该对象的状态
        private class InternalStateMachine implements StateMachine<S, T, E> {
            private final O operand;
            private S currentState;
    
            InternalStateMachine(O operand, S initialState) {
                this.operand = operand;
                this.currentState = initialState;
            }
    
            @Override
            public synchronized S getCurrentState() {
                return currentState;
            }
    
            @Override
            public synchronized S doTransition(T eventType, E event) {
                Map<T, Transition<O, E, S>> transitionMap = transitionMachineTable.get(currentState);
                if (transitionMap != null) {
                    Transition<O, E, S> transition = transitionMap.get(eventType);
                    if (transition != null) {
                        currentState = transition.transition(operand, event);
                        return currentState;
                    }
                }
                throw new RuntimeException("Invalid event: " + event + " at " + currentState);
            }
        }
    }
    ```

### (2) 案例测试

- **操作数类型**：

    ```java
    public class MyThreadContext {
    }
    ```

- **状态机状态枚举类型**：

    ```java
    public enum MyThreadState {
        NEW, //尚未启动的线程的线程状态
        RUNNABLE, //可运行线程的线程状态，等待CPU调度
        RUNNING, //Java没有，为了方便演示添加
        BLOCKED, //可运行线程的线程状态，等待 CPU 调度、等待锁或 IO
        WAITING, //线程无限阻塞(Object.wait)
        TIMED_WAITING, //线程有限阻塞(Thread.sleep、Object.wait、LockSupport.parkNanos、LockSupport.parkUntil)
        TERMINATED; //终止线程的线程状态(线程正常完成执行或出现异常)
    }
    ```

- **事件类型**(模拟 Java 线程状态转换)：

    ```java
    public enum MyThreadEventType {
        CallStart, //调用了 Start 方法
        ObtainCPU, //获得 CPU
        RunReturn, //调用了 Runnable.run 方法返回
        WaitingLock, //等待锁
        ObtainLock, //获得锁
        CallObjectWaitOrWaitIO, //Object.wait 或等待 IO
        CallObjectNotifyOrIOReady, //Object.notify 或 IO 就绪
        CallWithTimeout, //调用带有超时状态的方法
        TimeoutOrReturn, //带有超时状态的方法超时或返回
        CallInterrupt; //调用中断命令
    }
    ```

- **事件**：

    ```java
    @Data
    @AllArgsConstructor
    public class MyThreadEvent {
        private MyThreadEventType type;
    }
    ```

- 主测试类：

    ```java
    public class Main {
        @SuppressWarnings("PMD.MethodTooLongRule")
        public static void main(String[] args) {
            // 模拟线程状态转换
            StateMachineFactory stateMachineFactory = new StateMachineFactory<MyThreadContext, 
            											MyThreadState, MyThreadEventType, MyThreadEvent>();
    
            // NEW -> RUNNABLE
            stateMachineFactory.addTransition(MyThreadState.NEW, MyThreadState.RUNNABLE, 
                                              MyThreadEventType.CallStart, (o, e) -> {
                System.out.println("NEW -> RUNNABLE by event: " + e);
                return MyThreadState.RUNNABLE;
            });
    
            // RUNNABLE -> RUNNING
            stateMachineFactory.addTransition(MyThreadState.RUNNABLE, MyThreadState.RUNNING, 
                                              MyThreadEventType.ObtainCPU, (o, e) -> {
                System.out.println("RUNNABLE -> RUNNING by event: " + e);
                return MyThreadState.RUNNING;
            });
    
            // RUNNING -> BLOCKED | WAITING | TIMED_WAITING | TERMINATED
            stateMachineFactory.addTransition(MyThreadState.RUNNING, MyThreadState.BLOCKED, 
                                              MyThreadEventType.WaitingLock, (o, e) -> {
                System.out.println("RUNNING -> BLOCKED by event: " + e);
                return MyThreadState.BLOCKED;
            });
            stateMachineFactory.addTransition(MyThreadState.RUNNING, MyThreadState.WAITING, 
                                              MyThreadEventType.CallObjectWaitOrWaitIO, (o, e) -> {
                System.out.println("RUNNING -> WAITING by event: " + e);
                return MyThreadState.WAITING;
            });
            stateMachineFactory.addTransition(MyThreadState.RUNNING, MyThreadState.TIMED_WAITING, 
                                              MyThreadEventType.CallWithTimeout, (o, e) -> {
                System.out.println("RUNNING -> TIMED_WAITING by event: " + e);
                return MyThreadState.TIMED_WAITING;
            });
            stateMachineFactory.addTransition(MyThreadState.RUNNING, MyThreadState.TERMINATED, 
                                              MyThreadEventType.RunReturn, (o, e) -> {
                System.out.println("RUNNING -> TERMINATED by event: " + e);
                return MyThreadState.TERMINATED;
            });
    
            // BLOCKED -> RUNNABLE | TERMINATED
            stateMachineFactory.addTransition(MyThreadState.BLOCKED, MyThreadState.RUNNABLE, 
                                              MyThreadEventType.ObtainLock, (o, e) -> {
                System.out.println("BLOCKED -> RUNNABLE by event: " + e);
                return MyThreadState.RUNNABLE;
            });
            stateMachineFactory.addTransition(MyThreadState.BLOCKED, MyThreadState.TERMINATED, 
                                              MyThreadEventType.CallInterrupt, (o, e) -> {
                System.out.println("BLOCKED -> TERMINATED by event: " + e);
                return MyThreadState.TERMINATED;
            });
    
            // WAITING -> RUNNABLE | TERMINATED
            stateMachineFactory.addTransition(MyThreadState.WAITING, MyThreadState.RUNNABLE, 
                                              MyThreadEventType.CallObjectNotifyOrIOReady, (o, e) -> {
                System.out.println("WAITING -> RUNNABLE by event: " + e);
                return MyThreadState.RUNNABLE;
            });
            stateMachineFactory.addTransition(MyThreadState.WAITING, MyThreadState.TERMINATED, 
                                              MyThreadEventType.CallInterrupt, (o, e) -> {
                System.out.println("WAITING -> TERMINATED by event: " + e);
                return MyThreadState.TERMINATED;
            });
    
            // TIMED_WAITING -> RUNNABLE | TERMINATED
            stateMachineFactory.addTransition(MyThreadState.TIMED_WAITING, MyThreadState.RUNNABLE, 
                                              MyThreadEventType.TimeoutOrReturn, (o, e) -> {
                System.out.println("TIMED_WAITING -> RUNNABLE by event: " + e);
                return MyThreadState.RUNNABLE;
            });
            stateMachineFactory.addTransition(MyThreadState.TIMED_WAITING, MyThreadState.TERMINATED, 
                                              MyThreadEventType.CallInterrupt, (o, e) -> {
                System.out.println("TIMED_WAITING -> TERMINATED by event: " + e);
                return MyThreadState.TERMINATED;
            });
    
            StateMachine sm = stateMachineFactory.make(new MyThreadContext(), MyThreadState.NEW);
    
            sm.doTransition(MyThreadEventType.CallStart, new MyThreadEvent(MyThreadEventType.CallStart));
            sm.doTransition(MyThreadEventType.ObtainCPU, new MyThreadEvent(MyThreadEventType.ObtainCPU));
            sm.doTransition(MyThreadEventType.WaitingLock, 
                            new MyThreadEvent(MyThreadEventType.WaitingLock));
            sm.doTransition(MyThreadEventType.ObtainLock, new MyThreadEvent(MyThreadEventType.ObtainLock));
            sm.doTransition(MyThreadEventType.ObtainCPU, new MyThreadEvent(MyThreadEventType.ObtainCPU));
            sm.doTransition(MyThreadEventType.CallObjectWaitOrWaitIO, 
                            new MyThreadEvent(MyThreadEventType.CallObjectWaitOrWaitIO));
            sm.doTransition(MyThreadEventType.CallObjectNotifyOrIOReady, 
                            new MyThreadEvent(MyThreadEventType.CallObjectNotifyOrIOReady));
            sm.doTransition(MyThreadEventType.ObtainCPU, new MyThreadEvent(MyThreadEventType.ObtainCPU));
            sm.doTransition(MyThreadEventType.CallWithTimeout, 
                            new MyThreadEvent(MyThreadEventType.CallWithTimeout));
            sm.doTransition(MyThreadEventType.TimeoutOrReturn, 
                            new MyThreadEvent(MyThreadEventType.TimeoutOrReturn));
            sm.doTransition(MyThreadEventType.ObtainCPU, new MyThreadEvent(MyThreadEventType.ObtainCPU));
            sm.doTransition(MyThreadEventType.RunReturn, new MyThreadEvent(MyThreadEventType.RunReturn));
        }
    }
    ```

    ---

    输出：

    ```shell
    NEW -> RUNNABLE by event: MyThreadEvent [type=CallStart]
    RUNNABLE -> RUNNING by event: MyThreadEvent [type=ObtainCPU]
    RUNNING -> BLOCKED by event: MyThreadEvent [type=WaitingLock]
    BLOCKED -> RUNNABLE by event: MyThreadEvent [type=ObtainLock]
    RUNNABLE -> RUNNING by event: MyThreadEvent [type=ObtainCPU]
    RUNNING -> WAITING by event: MyThreadEvent [type=CallObjectWaitOrWaitIO]
    WAITING -> RUNNABLE by event: MyThreadEvent [type=CallObjectNotifyOrIOReady]
    RUNNABLE -> RUNNING by event: MyThreadEvent [type=ObtainCPU]
    RUNNING -> TIMED_WAITING by event: MyThreadEvent [type=CallWithTimeout]
    TIMED_WAITING -> RUNNABLE by event: MyThreadEvent [type=TimeoutOrReturn]
    RUNNABLE -> RUNNING by event: MyThreadEvent [type=ObtainCPU]
    RUNNING -> TERMINATED by event: MyThreadEvent [type=RunReturn]
    ```

# 二、状态模式(抽象类)实现

- `LiftState`：定义电梯行为：打开、关闭、运行、停止

    ```java
    //定义电梯行为：打开、关闭、运行、停止
    public abstract class LiftState {
        protected Lift mLift; // 拥有一个电梯对象，用于更新电梯当前状态
    
        //通过构造函数引入电梯的实例化对象
        public LiftState(Lift lift) {
            this.mLift = lift;
        }
    
        public abstract void open(); //行为：打开电梯门
        public abstract void close(); //行为：关闭电梯门
        public abstract void run(); //行为：电梯运行
        public abstract void stop(); //行为：电梯停止运行
    }
    ```

- **电梯的四种状态**：

    - `OpeningState`

        ```java
        public class OpeningState extends LiftState {
            public OpeningState(Lift lift) {
                super(lift);
            }
        
            // 执行开门动作
            @Override
            public void open() {
                System.out.println("执行开门动作"); 
            }
        
            // 执行关门动作
            @Override
            public void close() {
                mLift.setState(mLift.getCloseingState()); // 1、转化为关门状态
                mLift.close(); // 2、关门
            }
        
            @Override
            public void run() {
                // do noting
                // 开门状态，不能执行运行动作
            }
        
            @Override
            public void stop() {
                // do noting
                // 开门状态下，不执行停止动作
            }
        }
        ```

    - `ClosingState`

        ```java
        public class ClosingState extends LiftState {
            public ClosingState(Lift lift) {
                super(lift);
            }
        
            // 执行开门动作
            @Override
            public void open() {
                this.mLift.setState(mLift.getOpenningState()); // 1、变化为开门状态
                this.mLift.open(); // 2、开门
            }
        
            @Override
            public void close() {
                System.out.println("执行关门动作");
            }
        
            // 运行动作
            @Override
            public void run() {
                this.mLift.setState(mLift.getRunningState()); // 1、运行状态
                this.mLift.run(); // 2、运行动作
            }
        
            // 停止动作
            @Override
            public void stop() {
                this.mLift.setState(mLift.getStoppingState()); // 1、转化为停止状态
                this.mLift.stop(); // 2、停止
            }
        }
        ```

    - `RunningState`

        ```java
        public class RunningState extends LiftState {
            public RunningState(Lift lift) {
                super(lift);
            }
        
            @Override
            public void open() {
                // do noting
            }
        
            @Override
            public void close() {
                // do noting
            }
        
            // 运行动作
            @Override
            public void run() {
                System.out.println("电梯上下运行中...");
            }
        
            // 停止动作
            @Override
            public void stop() {
                this.mLift.setState(mLift.getStoppingState()); // 1、转化为停止状态
                this.mLift.stop(); // 2、停止动作
            }
        }
        ```

    - `StoppingState`

        ```java
        public class StoppingState extends LiftState {
            public StoppingState(Lift lift) {
                super(lift);
            }
        
            // 开门动作
            @Override
            public void open() {
                this.mLift.setState(mLift.getOpenningState()); // 1、开门状态
                this.mLift.open(); // 2、执行开门动作
            }
        
            @Override
            public void close() {
                // do noting
            }
        
            // 运行动作
            @Override
            public void run() {
                this.mLift.setState(mLift.getRunningState()); // 1、运行状态
                this.mLift.run(); // 2、运行动作
            }
        
            // 电梯停止动作
            @Override
            public void stop() {
                System.out.println("电梯停止运行...");
            }
        }
        ```

- **定义电梯类**：

    ```java
    //定义电梯类
    @Getter
    public class Lift {
        //定义出电梯的所有状态
        private LiftState openningState;
        private LiftState closingState;
        private LiftState runningState;
        private LiftState stoppingState;
    
        private LiftState mCurState; // 定义当前电梯状态
    
        //构造方法
        public Lift() {
            openningState = new OpeningState(this);
            closingState = new ClosingState(this);
            runningState = new RunningState(this);
            stoppingState = new StoppingState(this);
        }
    
        //执行开门动作
        public void open() {
            mCurState.open();
        }
    
        //执行关门动作
        public void close() {
            mCurState.close();
        }
    
        //执行运行动作
        public void run() {
            mCurState.run();
        }
    
        //执行停止动作
        public void stop() {
            mCurState.stop();
        }
    
        //设置当前电梯状态
        public void setState(LiftState state) {
            this.mCurState = state;
        }
    }
    ```

---

运行：

```java
public static void main(String[] args) {
    Lift lift = new Lift();
    lift.setState(new ClosingState(lift));
    lift.open();
    lift.close();
    lift.run();
    lift.stop();
}
```

结果：

```java
执行开门动作
执行关门动作
电梯上下运行中...
电梯停止运行...
```


# 三、开源状态机
## 1、squirrel-foundation

### (1) 简介







### (2) 案例

#### 0. 基本配置

- **maven 配置**：

    ```java
    <dependencies>
        <dependency>
            <groupId>org.squirrelframework</groupId>
            <artifactId>squirrel-foundation</artifactId>
            <version>0.3.8</version>
        </dependency>
    </dependencies>
    ```

- **事件监听器**：

    ```java
    //事件监听器
    public class StateListener {
        // 状态转换结束时被调用
        @OnTransitionEnd
        @ListenerOrder(10)
        public void transitionEnd() {
            System.out.println("[StateListener]------transitionEnd");
        }
    
        // 状态转换开始时被调用
        @OnTransitionBegin
        public void transitionBegin(MyEvent event) {
            System.out.println("[StateListener]------transitionBegin");
        }
    
        // 触发事件ToB时执行
        @OnTransitionBegin(when = "event.name().equals(\"ToB\")")
        public void transitionBeginConditional() {
            System.out.println("[StateListener]------transitionBeginConditional");
        }
    
        // 状态转换结束时执行
        @OnTransitionComplete
        public void transitionComplete(MyState from, MyState to, MyEvent event, MyContext context) {
            System.out.println("[StateListener]------transitionComplete");
        }
    
        @OnTransitionDecline
        public void transitionDeclined(MyState from, MyEvent event, MyContext context) {
            System.out.println("[StateListener]------transitionDeclined");
        }
    
        @OnBeforeActionExecuted
        public void onBeforeActionExecuted(MyState sourceState, MyState targetState,
                                MyEvent event, MyContext context, int[] mOfN, Action<?, ?, ?, ?> action) {
            System.out.println("[StateListener]------onBeforeActionExecuted");
        }
    
        @OnAfterActionExecuted
        public void onAfterActionExecuted(Object sourceState, Object targetState,
                                Object event, Object context, int[] mOfN, Action<?, ?, ?, ?> action) {
            System.out.println("[StateListener]------onAfterActionExecuted");
        }
    
        @OnActionExecException
        public void onActionExecException(Action<?, ?, ?, ?> action, TransitionException e) {
            System.out.println("[StateListener]------onActionExecException");
        }
    }
    ```

- 



#### 1. 案例一：单状态的进入与退出

```java
public class MainChild {
    public static void main(String[] args) {
        //1. 构建状态转换
        // StateMachineBuilder(状态机生成器)：使用Factory创建状态机生成器需要：状态机类型，状态类型，事件类型，上下文类型
        StateMachineBuilder<MyStateMachine, MyState, MyEvent, MyContext> builder
                = StateMachineBuilderFactory.create(MyStateMachine.class, 
                                                    MyState.class, MyEvent.class, MyContext.class);
        //-------------

        //2. 指定状态机触发状态过渡的事件以及动作(使用代码方式实现，也可以直接在状态机实现类使用注解实现)
        //进入和退出 A 状态时执行的动作(callMethod：动作，onEntry：事件[内置的事件])
        builder.onEntry(MyState.A).callMethod("entryStateA");
        builder.onExit(MyState.A).callMethod("exitStateA");

        //----
        //3. 使用状态机生成器创建状态机并指定初始状态
        MyStateMachine fsm = builder.newStateMachine(MyState.A);

        //4. 启动与终止
        fsm.start();
        fsm.terminate();
    }
}
```

**运行结果**：

```java
entryStateA-->
exitStateA-->
```

#### 2. 案例二：父状态串行子状态(未触发状态转换)

```java
public class MainChild {
    public static void main(String[] args) {
        //1. 构建状态转换
        // StateMachineBuilder(状态机生成器)：使用Factory创建状态机生成器需要：状态机类型，状态类型，事件类型，上下文类型
        StateMachineBuilder<MyStateMachine, MyState, MyEvent, MyContext> builder
                = StateMachineBuilderFactory.create(MyStateMachine.class, 
                                                    MyState.class, MyEvent.class, MyContext.class);
        //-------------

        //2. 指定状态机触发状态过渡的事件以及动作(使用代码方式实现，也可以直接在状态机实现类使用注解实现)
        //2.1 进入和退出 A 状态时执行的动作(callMethod：动作，onEntry：事件[内置的事件])
        builder.onEntry(MyState.A).callMethod("entryStateA");
        builder.onExit(MyState.A).callMethod("exitStateA");
        //2.2 进入和退出 Achild1 状态时执行的动作
        builder.onEntry(MyState.Achild1).callMethod("entryStateAChild1");
        builder.onExit(MyState.Achild1).callMethod("exitStateAChild1");
        //2.3 进入和退出 Achild2 状态时执行的动作
        builder.onEntry(MyState.Achild2).callMethod("entryStateAChild2");
        builder.onExit(MyState.Achild2).callMethod("exitStateAChild2");

        //2.4 配置父状态下串行子状态(A--->AChild1--->Achild2)，只需配置 Achild1 到 Achild2 的状态转移
        builder.defineSequentialStatesOn(MyState.A, MyState.Achild1, MyState.Achild2);
        builder.externalTransition().from(MyState.Achild1).to(MyState.Achild2)
            .on(MyEvent.ToAchild2).callMethod("fromAToAChild2");

        //----
        //3. 使用状态机生成器创建状态机并指定初始状态
        MyStateMachine fsm = builder.newStateMachine(MyState.A);

        //4. 启动与终止
        fsm.start();
        fsm.terminate();
    }
}
```

**运行结果**：

```java
entryStateA-->
entryStateAChild1-->
exitStateAChild1-->
exitStateA-->
```

#### 3. 案例三：父状态串行子状态(触发状态转换)

```java
public class MainChild {
    public static void main(String[] args) {
        //1. 构建状态转换
        // StateMachineBuilder(状态机生成器)：使用Factory创建状态机生成器需要：状态机类型，状态类型，事件类型，上下文类型
        StateMachineBuilder<MyStateMachine, MyState, MyEvent, MyContext> builder
                = StateMachineBuilderFactory.create(MyStateMachine.class, 
                                                    MyState.class, MyEvent.class, MyContext.class);
        //-------------

        //2. 指定状态机触发状态过渡的事件以及动作(使用代码方式实现，也可以直接在状态机实现类使用注解实现)
        //2.1 进入和退出 A 状态时执行的动作(callMethod：动作，onEntry：事件[内置的事件])
        builder.onEntry(MyState.A).callMethod("entryStateA");
        builder.onExit(MyState.A).callMethod("exitStateA");
        //2.2 进入和退出 Achild1 状态时执行的动作
        builder.onEntry(MyState.Achild1).callMethod("entryStateAChild1");
        builder.onExit(MyState.Achild1).callMethod("exitStateAChild1");
        //2.3 进入和退出 Achild2 状态时执行的动作
        builder.onEntry(MyState.Achild2).callMethod("entryStateAChild2");
        builder.onExit(MyState.Achild2).callMethod("exitStateAChild2");
        //2.4 配置父状态下串行子状态(A--->AChild1--->Achild2)，只需配置 Achild1 到 Achild2 的状态转移
        builder.defineSequentialStatesOn(MyState.A, MyState.Achild1, MyState.Achild2);
        builder.externalTransition().from(MyState.Achild1).to(MyState.Achild2)
            .on(MyEvent.ToAchild2).callMethod("fromAToAChild2");

        //----
        //3. 使用状态机生成器创建状态机并指定初始状态
        MyStateMachine fsm = builder.newStateMachine(MyState.A);

        //4. 启动
        fsm.start();
        
        //5. 触发状态机状态转换
        MyContext context = new MyContext(); // 状态机上下文
        fsm.fire(MyEvent.ToAchild2, context); //状态转换到 ToAchild2[可根据事件转换，或者上下文转换]

        //6. 终止
        fsm.terminate();
    }
}
```

**运行结果**：

```java
entryStateA-->
entryStateAChild1-->
exitStateAChild1-->
fromAToAChild2: AChild1-------->AChild2
entryStateAChild2-->
exitStateAChild2-->
exitStateA-->
```

#### 4. 案例四：开启监听器

```java
public class MainChild {
    public static void main(String[] args) {
        //1. 构建状态转换
        // StateMachineBuilder(状态机生成器)：使用Factory创建状态机生成器需要：状态机类型，状态类型，事件类型，上下文类型
        StateMachineBuilder<MyStateMachine, MyState, MyEvent, MyContext> builder
                = StateMachineBuilderFactory.create(MyStateMachine.class, 
                                                    MyState.class, MyEvent.class, MyContext.class);
        //-------------

        //2. 指定状态机触发状态过渡的事件以及动作(使用代码方式实现，也可以直接在状态机实现类使用注解实现)
        //2.1 进入和退出 A 状态时执行的动作(callMethod：动作，onEntry：事件[内置的事件])
        builder.onEntry(MyState.A).callMethod("entryStateA");
        builder.onExit(MyState.A).callMethod("exitStateA");
        //2.2 进入和退出 Achild1 状态时执行的动作
        builder.onEntry(MyState.Achild1).callMethod("entryStateAChild1");
        builder.onExit(MyState.Achild1).callMethod("exitStateAChild1");
        //2.3 进入和退出 Achild2 状态时执行的动作
        builder.onEntry(MyState.Achild2).callMethod("entryStateAChild2");
        builder.onExit(MyState.Achild2).callMethod("exitStateAChild2");
        //2.4 配置父状态下串行子状态(A--->AChild1--->Achild2)，只需配置 Achild1 到 Achild2 的状态转移
        builder.defineSequentialStatesOn(MyState.A, MyState.Achild1, MyState.Achild2);
        builder.externalTransition().from(MyState.Achild1).to(MyState.Achild2)
            .on(MyEvent.ToAchild2).callMethod("fromAToAChild2");

        //----
        //3. 使用状态机生成器创建状态机并指定初始状态
        MyStateMachine fsm = builder.newStateMachine(MyState.A);
        
        //4. 状态机配置监听器
        StateListener listener = new StateListener(); // 自定义监听器
        fsm.addDeclarativeListener(listener);

        //5. 启动
        fsm.start();
        //6. 触发状态机状态转换
        MyContext context = new MyContext(); // 状态机上下文
        fsm.fire(MyEvent.ToAchild2, context); //状态转换到 ToAchild2[可根据事件转换，或者上下文转换]

        //7. 终止
        fsm.terminate();
    }
}
```

**运行结果**：

```java
[StateListener]------onBeforeActionExecuted
entryStateA-->
[StateListener]------onAfterActionExecuted
[StateListener]------onBeforeActionExecuted
entryStateAChild1-->
[StateListener]------onAfterActionExecuted
[StateListener]------transitionBegin
[StateListener]------onBeforeActionExecuted
exitStateAChild1-->
[StateListener]------onAfterActionExecuted
[StateListener]------onBeforeActionExecuted
fromAToAChild2: AChild1-------->AChild2
[StateListener]------onAfterActionExecuted
[StateListener]------onBeforeActionExecuted
entryStateAChild2-->
[StateListener]------onAfterActionExecuted
[StateListener]------transitionComplete
[StateListener]------transitionEnd
[StateListener]------onBeforeActionExecuted
exitStateAChild2-->
[StateListener]------onAfterActionExecuted
[StateListener]------onBeforeActionExecuted
exitStateA-->
[StateListener]------onAfterActionExecuted
```

#### 5. 案例五：状态机监控

```java
public class MainChild {
    public static void main(String[] args) {
        //1. 构建状态转换
        // StateMachineBuilder(状态机生成器)：使用Factory创建状态机生成器需要：状态机类型，状态类型，事件类型，上下文类型
        StateMachineBuilder<MyStateMachine, MyState, MyEvent, MyContext> builder
                = StateMachineBuilderFactory.create(MyStateMachine.class, 
                                                    MyState.class, MyEvent.class, MyContext.class);
        //-------------

        //2. 指定状态机触发状态过渡的事件以及动作(使用代码方式实现，也可以直接在状态机实现类使用注解实现)
        //2.1 进入和退出 A 状态时执行的动作(callMethod：动作，onEntry：事件[内置的事件])
        builder.onEntry(MyState.A).callMethod("entryStateA");
        builder.onExit(MyState.A).callMethod("exitStateA");
        //2.2 进入和退出 Achild1 状态时执行的动作
        builder.onEntry(MyState.Achild1).callMethod("entryStateAChild1");
        builder.onExit(MyState.Achild1).callMethod("exitStateAChild1");
        //2.3 进入和退出 Achild2 状态时执行的动作
        builder.onEntry(MyState.Achild2).callMethod("entryStateAChild2");
        builder.onExit(MyState.Achild2).callMethod("exitStateAChild2");
        //2.4 配置父状态下串行子状态(A--->AChild1--->Achild2)，只需配置 Achild1 到 Achild2 的状态转移
        builder.defineSequentialStatesOn(MyState.A, MyState.Achild1, MyState.Achild2);
        builder.externalTransition().from(MyState.Achild1).to(MyState.Achild2)
            .on(MyEvent.ToAchild2).callMethod("fromAToAChild2");

        //----
        //3. 使用状态机生成器创建状态机并指定初始状态
        MyStateMachine fsm = builder.newStateMachine(MyState.A);
        //4. 状态机配置监听器
        StateListener listener = new StateListener(); // 自定义监听器
        fsm.addDeclarativeListener(listener);

        //5. 启动
        fsm.start();
        
        //6. 触发状态机状态转换
        MyContext context = new MyContext(); // 状态机上下文
        fsm.fire(MyEvent.ToAchild2, context); //状态转换到 ToAchild2[可根据事件转换，或者上下文转换]

        //7. 状态机监控，统计
        StateMachinePerformanceMonitor performanceMonitor
                = new StateMachinePerformanceMonitor("My State Machine Performance Info");
        fsm.addDeclarativeListener(performanceMonitor);
        fsm.removeDeclarativeListener(performanceMonitor);
        System.out.println(performanceMonitor.getPerfModel());
        System.out.println("父状态下的并行子状态：" + fsm.getSubStatesOn(MyState.C));
        System.out.println("Current state is [" + fsm.getCurrentState() + "]");

        //8. 终止
        fsm.terminate();
    }
}
```

**运行结果**：

```java
[StateListener]------onBeforeActionExecuted
entryStateA-->
[StateListener]------onAfterActionExecuted
[StateListener]------onBeforeActionExecuted
entryStateAChild1-->
[StateListener]------onAfterActionExecuted
[StateListener]------transitionBegin
[StateListener]------onBeforeActionExecuted
exitStateAChild1-->
[StateListener]------onAfterActionExecuted
[StateListener]------onBeforeActionExecuted
fromAToAChild2: AChild1-------->AChild2
[StateListener]------onAfterActionExecuted
[StateListener]------onBeforeActionExecuted
entryStateAChild2-->
[StateListener]------onAfterActionExecuted
[StateListener]------transitionComplete
[StateListener]------transitionEnd
========================== My State Machine Performance Info ==========================
Total Transition Invoked: 0
Total Transition Failed: 0
Total Transition Declained: 0
Average Transition Comsumed: 0.0000ms
	Transition Key		Invoked Times	Average Time		Max Time	Min Time

Total Action Invoked: 0
Total Action Failed: 0
Average Action Execution Comsumed: 0.0000ms
	Action Key		Invoked Times	Average Time		Max Time	Min Time
========================== My State Machine Performance Info ==========================

父状态下的并行子状态：[]
Current state is [Achild2]
[StateListener]------onBeforeActionExecuted
exitStateAChild2-->
[StateListener]------onAfterActionExecuted
[StateListener]------onBeforeActionExecuted
exitStateA-->
[StateListener]------onAfterActionExecuted
```

#### 6. 案例六：开启系统日志

```java
public class MainChild {
    public static void main(String[] args) {
        //1. 构建状态转换
        // StateMachineBuilder(状态机生成器)：使用Factory创建状态机生成器需要：状态机类型，状态类型，事件类型，上下文类型
        StateMachineBuilder<MyStateMachine, MyState, MyEvent, MyContext> builder
                = StateMachineBuilderFactory.create(MyStateMachine.class, 
                                                    MyState.class, MyEvent.class, MyContext.class);
        //-------------

        //2. 指定状态机触发状态过渡的事件以及动作(使用代码方式实现，也可以直接在状态机实现类使用注解实现)
        //2.1 进入和退出 A 状态时执行的动作(callMethod：动作，onEntry：事件[内置的事件])
        builder.onEntry(MyState.A).callMethod("entryStateA");
        builder.onExit(MyState.A).callMethod("exitStateA");
        //2.2 进入和退出 Achild1 状态时执行的动作
        builder.onEntry(MyState.Achild1).callMethod("entryStateAChild1");
        builder.onExit(MyState.Achild1).callMethod("exitStateAChild1");
        //2.3 进入和退出 Achild2 状态时执行的动作
        builder.onEntry(MyState.Achild2).callMethod("entryStateAChild2");
        builder.onExit(MyState.Achild2).callMethod("exitStateAChild2");
        //2.4 配置父状态下串行子状态(A--->AChild1--->Achild2)，只需配置 Achild1 到 Achild2 的状态转移
        builder.defineSequentialStatesOn(MyState.A, MyState.Achild1, MyState.Achild2);
        builder.externalTransition().from(MyState.Achild1).to(MyState.Achild2)
            .on(MyEvent.ToAchild2).callMethod("fromAToAChild2");

        //----
        //3. 使用状态机生成器创建状态机并指定初始状态
        MyStateMachine fsm = builder.newStateMachine(MyState.A);
        
        //4.1 开启日志
        StateMachineLogger fsmLogger = new StateMachineLogger(fsm);
        fsmLogger.startLogging();
        //5. 状态机配置监听器
        StateListener listener = new StateListener(); // 自定义监听器
        fsm.addDeclarativeListener(listener);

        //6. 启动
        fsm.start();
        //7. 触发状态机状态转换
        MyContext context = new MyContext(); // 状态机上下文
        fsm.fire(MyEvent.ToAchild2, context); //状态转换到 ToAchild2[可根据事件转换，或者上下文转换]

        //4.2 结束日志
        fsmLogger.stopLogging();

        //8. 状态机监控，统计
        StateMachinePerformanceMonitor performanceMonitor
                = new StateMachinePerformanceMonitor("My State Machine Performance Info");

        fsm.addDeclarativeListener(performanceMonitor);
        fsm.removeDeclarativeListener(performanceMonitor);
        System.out.println(performanceMonitor.getPerfModel());
        System.out.println("父状态下的并行子状态：" + fsm.getSubStatesOn(MyState.C));
        System.out.println("Current state is [" + fsm.getCurrentState() + "]");

        //9. 终止
        fsm.terminate();
    }
}
```

#### 7. 案例七：添加 condition

```java
public class MainChild {
    public static void main(String[] args) {
        //1. 构建状态转换
        // StateMachineBuilder(状态机生成器)：使用Factory创建状态机生成器需要：状态机类型，状态类型，事件类型，上下文类型
        StateMachineBuilder<MyStateMachine, MyState, MyEvent, MyContext> builder
                = StateMachineBuilderFactory.create(MyStateMachine.class, 
                                                    MyState.class, MyEvent.class, MyContext.class);
        //-------------

        //2. 指定状态机触发状态过渡的事件以及动作(使用代码方式实现，也可以直接在状态机实现类使用注解实现)
        //进入和退出 A 状态时执行的动作(callMethod：动作，onEntry：事件[内置的事件])
        builder.onEntry(MyState.A).callMethod("entryStateA");
        builder.onExit(MyState.A).callMethod("exitStateA");

        //3. 从状态A过渡到状态B执行的动作(externalTransition：配置过渡的方法，callMethod：动作，on：配置事件)
        //3.1 进入和退出 B 状态时执行的动作
        builder.onEntry(MyState.B).callMethod("entryStateB");
        builder.onExit(MyState.B).callMethod("exitStateB");
        //3.2 MVEL来描述条件，:::分离条件名称和表达式，满足则状态转移，反之状态不转移
        builder.externalTransition().from(MyState.A).to(MyState.B).on(MyEvent.ToB)
                .whenMvel("MyCondition:::(1==1 && 2>1)").callMethod("stateAToStateBOnGotoB");

        // 4. 由状态B转移到状态C
        MyCondition condition = new MyCondition(); // 自定义条件过滤器
        builder.externalTransition().from(MyState.B).to(MyState.C).on(MyEvent.ToC)
                .when(condition).callMethod("stateBToStateCOnGotoC");
        builder.onEntry(MyState.C).callMethod("entryStateC");

        //----
        //8. 使用状态机生成器创建状态机并指定初始状态
        MyStateMachine fsm = builder.newStateMachine(MyState.A);

        //9. 启动
        fsm.start();
        //10. 触发状态机状态转换
        MyContext context = new MyContext(); // 状态机上下文
        fsm.fire(MyEvent.ToB, context); //状态转换到 B
        fsm.fire(MyEvent.ToC, context); //状态转换到 C

        //12. 终止
        fsm.terminate();
    }
}
```

`MyCondition`：

```java
//自定义过滤条件类
public class MyCondition extends AnonymousCondition<MyContext> {
    // 框架回调判断
    public boolean isSatisfied(MyContext context) {
        return 2 > 1;
    }
}
```

**运行结果**：

```java
entryStateA-->
exitStateA-->
stateAToStateBOnGotoB: A-------->B
entryStateB-->
exitStateB-->
stateBToStateCOnGotoC: B-------->C
entryStateC-->
```

#### 8. 案例八：







#### 9. 案例九：









### (3) 注解实现









## 2、stateless4j

### (1) 使用浅析一：简单使用

- 超级玛丽所有存在的状态state

    ```java
    public enum CurrentState {
        SMALL, //初始化时小形态
        BIG, //吃到一个蘑菇时的大形态
        ATTACH, //吃到花朵,可攻击形态
        DEAD //godead
    }
    ```

- 超级玛丽会遇到触发状态改变的trigger

    ```java
    public enum Trigger {
        MUSHROOM, //蘑菇
        FLOWER, //花朵
        MONSTER //妖怪
    }
    ```

- state和trigger注册

    ```java
    public class StateConver {
        private static StateMachineConfig<CurrentState,Trigger> config = new StateMachineConfig<>();
    
        static {
            //最初为small状态时
            config.configure(CurrentState.SMALL)
                    .permit(Trigger.MUSHROOM, CurrentState.BIG) //遇到蘑菇触发-->big状态
                    .permit(Trigger.FLOWER, CurrentState.ATTACH) //花朵触发,-->直接变为可攻击状态
                    .permit(Trigger.MONSTER, CurrentState.DEAD); //妖怪触发,死亡状态
    
            //最初为big状态
            config.configure(CurrentState.BIG)
                    // 蘑菇触发,状态不变,permitReentry方法state变化相同,但具体执行过程有一些区别
                    .ignore(Trigger.MUSHROOM)
                    .permit(Trigger.FLOWER, CurrentState.ATTACH)
                    .permit(Trigger.MONSTER, CurrentState.SMALL);
    
            config.configure(CurrentState.ATTACH)
                    .ignore(Trigger.MUSHROOM)
                    .ignore(Trigger.FLOWER)
                    .permit(Trigger.MONSTER,CurrentState.SMALL);
    
            config.configure(CurrentState.DEAD)
                    .ignore(Trigger.MUSHROOM)
                    .ignore(Trigger.FLOWER)
                    .ignore(Trigger.MONSTER);
        }
    }
    ```

- 状态机测试类

    ```java
    public class RunStateMachine {
        private static StateMachine<CurrentState, Trigger> stateMachine 
            = new StateMachine<CurrentState, Trigger>(CurrentState.SMALL, StateConver.config);
    
        @Test
        public void testStateMachine(){
            stateMachine.fire(Trigger.FLOWER);
            System.out.println("currentState-->" + stateMachine.getState());
        }
    }
    
    //结果
    currentState-->ATTACH
    ```

### (2) 使用浅析二：Exit 与 Entry Action

- state和trigger注册

    ```java
    public class StateConver {
        public static StateMachineConfig<CurrentState, Trigger> config = new StateMachineConfig<>();
    
        static {
            //最初为small状态时
            config.configure(CurrentState.SMALL)
                    .onExit(new ExitAction()) //从当前状态改变时所触发的动作
                    .onEntry(new EntryAction()) //改变到当前状态时所触发的动作
                    .permit(Trigger.MUSHROOM,CurrentState.BIG) //遇到蘑菇触发-->big状态
                    .permit(Trigger.FLOWER,CurrentState.ATTACH) //花朵触发-->直接变为可攻击状态
                    .permit(Trigger.MONSTER,CurrentState.DEAD); //妖怪触发,死亡状态
    
            //最初为big状态
            config.configure(CurrentState.BIG)
                    //蘑菇触发,状态不变,permitReentry方法state变化相同,但具体执行过程有一些区别
                    .ignore(Trigger.MUSHROOM)
                    .permit(Trigger.FLOWER,CurrentState.ATTACH)
                    .permit(Trigger.MONSTER,CurrentState.SMALL);
    
            config.configure(CurrentState.ATTACH)
                    .ignore(Trigger.MUSHROOM)
                    .ignore(Trigger.FLOWER)
                    .permit(Trigger.MONSTER,CurrentState.SMALL);
    
            config.configure(CurrentState.DEAD)
                    .ignore(Trigger.MUSHROOM)
                    .ignore(Trigger.FLOWER)
                    .ignore(Trigger.MONSTER);
        }
    }
    ```

- ExitAction实现类

    ```java
    public class ExitAction implements Action1<Transition<CurrentState,Trigger>> {
        @Override
        public void doIt(Transition<CurrentState, Trigger> arg1) {
            System.out.println("OUT FROM :" + arg1.getSource());
        }
    }
    ```

- EntryAction实现类

    ```java
    public class EntryAction implements Action1<Transition<CurrentState,Trigger>> {
        @Override
        public void doIt(Transition<CurrentState, Trigger> arg1) {
            System.out.println("ENTRY TO : " + arg1.getDestination());
        }
    }
    ```

- 状态机测试类

    ```java
    public class RunStateMachine {
        private static StateMachine<CurrentState,Trigger> stateMachine 
            = new StateMachine<CurrentState, Trigger>(CurrentState.SMALL,StateConver.config);
    
        @Test
        public void testStateMachine(){
            stateMachine.fire(Trigger.FLOWER);
            System.out.println("currentState-->" + stateMachine.getState());
        }
    }
    
    //结果
    OUT FROM :SMALL
    currentState-->ATTACH
    ```

- 触发一个EntryAction动作

    ```java
    @Test
    public void testStateMachine(){
        stateMachine.fire(Trigger.FLOWER);
        System.out.println("currentState-->"+stateMachine.getState());
        stateMachine.fire(Trigger.MONSTER);
    }
    
    //结果
    OUT FROM :SMALL
    currentState-->ATTACH
    ENTRY TO : SMALL
    ```

## 3、spring-statemachine













# 四、Scala 之 Akka FSM







